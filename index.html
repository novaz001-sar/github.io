<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>认知能力训练挑战 (V21.2 - 地图更新)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            background-color: #000;
            color: white;
        }
        canvas {
            display: block;
        }
        .overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            z-index: 11;
        }
        #instructions {
            font-size: 18px;
            font-weight: bold;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            text-shadow: 2px 2px 4px #000000;
            pointer-events: none;
            width: 350px;
            line-height: 1.6;
            z-index: 10;
        }
        
        /* --- NEW: Crosshair Styles --- */
        @keyframes crosshair-flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
        }
        #crosshair > div { /* Vertical bar container */
            position: absolute;
            transform: translate(-50%, -50%);
        }
        #crosshair > div::after { /* Horizontal bar */
            content: '';
            position: absolute;
        }

        /* Default Style */
        .crosshair-default > div {
            width: 2px;
            height: 20px;
            background-color: white;
            box-shadow: 0 0 0 2px red;
            border-radius: 1px;
        }
        .crosshair-default > div::after {
            top: 9px;
            left: -9px;
            width: 20px;
            height: 2px;
            background-color: white;
            box-shadow: 0 0 0 2px red;
            border-radius: 1px;
        }

        /* Turret Level Style */
        .crosshair-turret > div {
            width: 2px;
            height: 16px; /* Smaller */
            background-color: #00ff00;
            box-shadow: 0 0 6px #00ff00, 0 0 12px #00ff00;
            border-radius: 1px;
            animation: crosshair-flash 1.2s ease-in-out infinite;
        }
        .crosshair-turret > div::after {
            top: 7px; /* Adjusted */
            left: -7px; /* Adjusted */
            width: 16px; /* Smaller */
            height: 2px;
            background-color: #00ff00;
            box-shadow: 0 0 6px #00ff00, 0 0 12px #00ff00;
            border-radius: 1px;
        }
        /* --- End of Crosshair Styles --- */


        #blocker {
            cursor: pointer;
        }
        #key-display {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .key-row {
            display: flex;
            justify-content: center;
            gap: 5px;
        }
        .key {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            line-height: 1.2;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: all 0.1s ease;
        }
        .key-long {
            width: 194px;
        }
        .key-active {
            background-color: rgba(255, 255, 255, 0.8);
            color: black;
            transform: scale(0.95);
        }
        #npc-counter, #landmark-counter, #generic-counter, #map-uses-counter {
            position: absolute;
            top: 100px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            display: none;
        }
        #landmark-counter { top: 100px; }
        #map-uses-counter { top: 140px; font-size: 20px; color: #ffdd57; }
        #timer, #warmup-timer-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            display: none;
            font-family: 'Courier New', Courier, monospace;
        }

        #menu-overlay {
            display: none;
            z-index: 12;
        }
        #menu-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }
        .menu-button, .mode-button {
            background-color: #444;
            border: 2px solid #888;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 12px;
            width: 280px;
            transition: background-color: 0.3s, transform 0.1s;
            flex-shrink: 0;
        }
        .menu-button:hover, .mode-button:hover {
            background-color: #666;
        }
        .menu-button:active, .mode-button:active {
            transform: scale(0.98);
        }
        .menu-button.disabled {
            background-color: #222;
            color: #666;
            border-color: #444;
            cursor: not-allowed;
        }
        #reset-game-button {
            background-color: #b22222;
            border-color: #ff6347;
        }
        #reset-game-button:hover {
            background-color: #dc143c;
        }
        .level-time {
            font-size: 12px;
            color: #ffdd57;
            margin-top: 5px;
            font-weight: normal;
        }
        #level-select-menu {
            display: none;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }
        #menu-content::-webkit-scrollbar { width: 8px; }
        #menu-content::-webkit-scrollbar-track { background: #222; border-radius: 4px; }
        #menu-content::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        #menu-content::-webkit-scrollbar-thumb:hover { background: #555; }
        
        #mode-selection {
            z-index: 13;
        }
        #mode-selection h1 {
            font-size: 36px;
            margin-bottom: 30px;
            text-shadow: 3px 3px 6px #000;
        }
        .mode-button {
            margin: 10px;
        }

        #minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff;
            border-radius: 10px;
            display: none;
            z-index: 10;
        }
        #minimap {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        #narration-box {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #888;
            font-size: 16px;
            text-align: center;
            line-height: 1.5;
            z-index: 15;
            display: none;
            max-width: 80%;
            pointer-events: none;
        }
        
        #profile-form, .confirm-box {
            background-color: rgba(20, 20, 20, 0.9);
            padding: 30px 40px;
            border-radius: 20px;
            border: 2px solid #888;
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 90%;
            max-width: 450px;
        }
        #profile-form h2, .confirm-box h2 {
            margin: 0 0 10px 0;
            font-size: 28px;
            color: #ffdd57;
            text-shadow: 2px 2px 4px #000;
        }
        #nickname-input {
            padding: 12px;
            font-size: 16px;
            border-radius: 8px;
            border: 2px solid #555;
            background-color: #333;
            color: white;
            text-align: center;
        }
        #nickname-input::placeholder {
            color: #999;
        }
        #gender-select {
            display: flex;
            gap: 15px;
        }
        #gender-select button {
            flex: 1;
            padding: 12px;
            font-size: 16px;
            cursor: pointer;
            border: 2px solid #888;
            border-radius: 8px;
            background-color: #444;
            color: white;
            transition: all 0.2s ease;
        }
        #gender-select button.selected {
            background-color: #ffdd57;
            color: black;
            border-color: #fff;
            transform: scale(1.05);
        }
        #start-campaign-button {
            padding: 15px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 10px;
            border: none;
            background-color: #4CAF50;
            color: white;
            transition: background-color: 0.3s;
        }
        #start-campaign-button:hover {
            background-color: #45a049;
        }

        #star-container {
            font-size: 50px;
            margin-top: 15px;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        .star-filled {
            color: #ffdd57;
        }
        .star-empty {
            color: #555;
        }
        .level-stars {
            font-size: 14px;
            color: #ffdd57;
            margin-left: 10px;
        }

        #player-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 10px;
            border: 1px solid #888;
            text-align: left;
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            z-index: 10;
            display: none;
        }
        #player-name {
            font-size: 18px;
            color: #ffdd57;
        }
        #player-stars {
            margin-top: 5px;
        }

        #results-overlay {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(180deg, rgba(20,20,40,0.95) 0%, rgba(40,20,50,0.95) 100%);
            z-index: 15;
            padding: 20px;
            box-sizing: border-box;
        }
        #results-content {
            background-color: rgba(0,0,0,0.4);
            border: 2px solid #ffdd57;
            border-radius: 20px;
            padding: 30px 40px;
            width: 90%;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 221, 87, 0.5);
        }
        #results-title {
            font-size: 36px;
            font-weight: bold;
            color: #ffdd57;
            margin-bottom: 10px;
            text-shadow: 3px 3px 5px #000;
        }
        #player-final-title {
            font-size: 24px;
            margin-bottom: 20px;
        }
        #podium-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 5px;
            height: 180px;
            margin-bottom: 20px;
        }
        .podium-step {
            width: 100px;
            border-radius: 8px 8px 0 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: black;
            font-weight: bold;
            padding: 10px;
            box-sizing: border-box;
            line-height: 1.2;
        }
        #podium-2 { background: linear-gradient(45deg, #c0c0c0, #a9a9a9); height: 120px; border: 2px solid #e0e0e0; }
        #podium-1 { background: linear-gradient(45deg, #ffd700, #f0c000); height: 160px; border: 2px solid #fff0a0; }
        #podium-3 { background: linear-gradient(45deg, #cd7f32, #a0522d); height: 90px; border: 2px solid #e09f50; }
        .podium-rank {
            font-size: 24px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        .podium-rank-en {
            font-size: 14px;
        }
        .podium-stars {
            font-size: 18px;
            margin-top: 5px;
        }
        #encouragement-message {
            font-size: 18px;
            line-height: 1.6;
            margin-top: 20px;
            margin-bottom: 30px;
            color: #f0f0f0;
        }
        #encouragement-message .en {
            font-size: 14px;
            color: #ccc;
            margin-top: 8px;
            display: block;
        }
        #close-results-button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 12px;
            transition: background-color: 0.3s;
        }
        #close-results-button:hover {
            background-color: #45a049;
        }
        
        #training-command {
            position: absolute;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            display: none;
            background-color: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 10;
        }
        #training-choice-box {
            background-color: rgba(20, 20, 20, 0.9);
            padding: 30px 40px;
            border-radius: 20px;
            border: 2px solid #888;
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 90%;
            max-width: 450px;
        }
        
        #player-health-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 25px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #888;
            border-radius: 12px;
            display: none;
            z-index: 10;
            overflow: hidden;
        }
        #player-health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff416c, #ff4b2b);
            border-radius: 8px;
            transition: width 0.3s ease-out;
        }
        #player-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 1px 1px 2px #000;
        }

    </style>
</head>
<body>
    <div id="mode-selection" class="overlay">
        <h1>选择训练模式 / Select Mode</h1>
        <button id="campaign-mode-button" class="mode-button">生涯模式<br><span style="font-size:12px;">Campaign Mode</span></button>
        <button id="free-mode-button" class="mode-button">自由模式<br><span style="font-size:12px;">Free Mode</span></button>
    </div>

    <div id="profile-creation-overlay" class="overlay" style="display: none; z-index: 14;">
        <div id="profile-form">
            <h2>创建您的档案 / Create Your Profile</h2>
            <input type="text" id="nickname-input" placeholder="请输入您的昵称 / Enter Nickname">
            <div id="gender-select">
                <button id="male-button" data-gender="male">我是叔叔 / I am Uncle</button>
                <button id="female-button" data-gender="female">我是阿姨 / I am Auntie</button>
            </div>
            <button id="start-campaign-button">开始训练 / Start Training</button>
        </div>
    </div>

    <div id="player-info">
        <div id="player-name"></div>
        <div id="player-stars"></div>
    </div>

    <div id="blocker" class="overlay" style="display: none;">
        <div id="instructions">
            <div id="instruction-text"></div>
            <div id="star-container"></div>
        </div>
    </div>
    
    <div id="results-overlay" class="overlay">
        <div id="results-content">
            <h1 id="results-title">能力认证 / Cognitive Mastery</h1>
            <p id="player-final-title"></p>
            <div id="podium-container">
                <div id="podium-2" class="podium-step"></div>
                <div id="podium-1" class="podium-step"></div>
                <div id="podium-3" class="podium-step"></div>
            </div>
            <p id="encouragement-message"></p>
            <button id="close-results-button">太棒了！ / Awesome! (Back to Menu)</button>
        </div>
    </div>

    <div id="training-choice-overlay" class="overlay" style="display: none; z-index: 16;">
        <div id="training-choice-box" class="confirm-box">
            <h2>移动特训 / Movement Special Training</h2>
            <p style="font-size: 16px; line-height: 1.5;">
                您想开始带有指令的移动特训吗？<br>
                <span style="font-size: 14px; color: #ccc;">Would you like to start special training with commands?</span>
            </p>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button id="training-yes" class="menu-button" style="width: 150px;">是 / Yes</button>
                <button id="training-no" class="menu-button" style="width: 150px; background-color: #777;">否 / No</button>
            </div>
        </div>
    </div>
    
    <div id="reset-confirm-overlay" class="overlay" style="display: none; z-index: 16;">
        <div id="reset-confirm-box" class="confirm-box">
            <h2>重置档案？ / Reset Profile?</h2>
            <p style="font-size: 16px; line-height: 1.5;">
                您确定要清除所有训练记录吗？此操作无法撤销。<br>
                <span style="font-size: 14px; color: #ccc;">Are you sure you want to erase all progress? This action cannot be undone.</span>
            </p>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button id="reset-confirm-yes" class="menu-button" style="width: 150px; background-color: #b22222;">确定 / Confirm</button>
                <button id="reset-confirm-no" class="menu-button" style="width: 150px;">取消 / Cancel</button>
            </div>
        </div>
    </div>

    <div id="warmup-confirm-overlay" class="overlay" style="display: none; z-index: 17;">
        <div id="warmup-confirm-box" class="confirm-box">
            <h2>开始训练？ / Start Training?</h2>
            <p style="font-size: 16px; line-height: 1.5;">
                热身结束！准备好开始第一项认知训练了吗？<br>
                <span style="font-size: 14px; color: #ccc;">Warm-up complete! Are you ready to start the first cognitive training?</span>
            </p>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button id="warmup-confirm-yes" class="menu-button" style="width: 150px;">准备好了 / Yes</button>
                <button id="warmup-confirm-no" class="menu-button" style="width: 150px; background-color: #777;">再等等 / Not Yet</button>
            </div>
        </div>
    </div>


    <div id="training-command"></div>

    <!-- MODIFIED: Added inner div for style toggling -->
    <div id="crosshair"><div></div></div>

    <div id="timer">0.00s</div>
    <div id="warmup-timer-display"></div>
    <div id="minimap-container"><canvas id="minimap"></canvas></div>
    <div id="narration-box"></div>

    <div id="menu-overlay" class="overlay">
        <div id="menu-content">
            <button class="menu-button" id="resume-button">继续训练<br>Resume</button>
            <button class="menu-button" id="restart-button">重新开始<br>Restart</button>
            <button class="menu-button" id="select-level-button">选择关卡<br>Select Level</button>
            <div id="level-select-menu"></div>
            <button class="menu-button" id="warmup-button">返回热身<br>Warm-up</button>
            <button class="menu-button" id="main-menu-button">返回主菜单<br>Main Menu</button>
            <button class="menu-button" id="reset-game-button">重置档案<br>Reset Profile</button>
        </div>
    </div>

    <div id="npc-counter"></div>
    <div id="landmark-counter"></div>
    <div id="generic-counter"></div>
    <div id="map-uses-counter"></div>

    <div id="key-display">
        <div class="key-row">
            <div class="key" id="key-w">W</div>
        </div>
        <div class="key-row">
            <div class="key" id="key-a">A</div>
            <div class="key" id="key-s">S</div>
            <div class="key" id="key-d">D</div>
        </div>
        <div class="key-row">
           <div class="key key-long" id="key-space">空格<br>Space</div>
        </div>
         <div class="key-row">
            <div class="key key-long" id="key-shift">Shift</div>
        </div>
    </div>

    <div id="player-health-container">
        <div id="player-health-bar"></div>
        <div id="player-health-text"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Basic Setup ---
        let scene, camera, renderer;
        let playerVelocity, playerOnFloor;
        const playerHeight = 1.8;
        const playerCrouchHeight = 1.0;
        const playerRadius = 0.5;
        let isCrouching = false;
        
        const moveSpeed = 5.0;
        const crouchSpeed = 2.5;
        const keys = {};
        const clock = new THREE.Clock();
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;

        const gravity = 30.0;
        const jumpForce = 10.0;
        
        // --- Game Logic Variables ---
        let currentStage = -1;
        let gameMode = '';
        let unlockedLevel = 1;
        let levelTimes = {};
        let canPlayerMove = true;
        let hasPlayerMoved = false;

        // --- Player Combat Variables ---
        let playerHealth = 3;
        const maxPlayerHealth = 3;
        let isPlayerDead = false;

        // --- Reward System Variables ---
        let playerProfile = { nickname: '', title: '' };
        let levelStars = {};
        let starTimeThresholds = {
            1: { s3: 5,   s2: 10 },   // Attention: Point Focus
            2: { s3: 15,  s2: 25 },   // Reaction: Quick Response (Adjusted)
            3: { s3: 20,  s2: 30 },   // Processing: Dynamic Tracking (Adjusted)
            4: { s3: 25,  s2: 40 },   // Prediction: Trajectory Forecast (Adjusted)
            5: { s3: 30,  s2: 45 },   // Coordination: Synchronized Tasks
            6: { s3: 20,  s2: 30 },   // Spatial Planning: Blueprint Navigation (Adjusted)
            7: { s3: 15,  s2: 20 },   // Motor Skills: Rhythmic Leap (Adjusted)
            8: { s3: 20,  s2: 25 },   // Cognitive Flexibility: Task Switching (Adjusted)
            9: { s3: 25,  s2: 40 },   // Working Memory: Maze Sprint I (Adjusted)
            10: { s3: 40, s2: 60 },   // Working Memory: Maze Sprint II (Adjusted)
            11: { s3: 60, s2: 80 },   // Working Memory: Maze Sprint III (Adjusted)
            12: { s3: 80, s2: 110 },  // Working Memory: Maze Sprint IV (Adjusted)
            13: { s3: 30, s2: 45 },   // Strategic Thinking: Dynamic Chase I
            14: { s3: 45, s2: 60 },   // Strategic Thinking: Dynamic Chase II
            15: { s3: 60, s2: 75 },   // Strategic Thinking: Dynamic Chase III
            16: { s3: 40, s2: 55 },   // Sequential Memory: Landmark Trace I (Adjusted)
            17: { s3: 50, s2: 65 },   // Sequential Memory: Landmark Trace II (Adjusted)
            18: { s3: 70, s2: 90 },   // Sequential Memory: Landmark Trace III (Adjusted)
            19: { s3: 80, s2: 100 },  // Sequential Memory: Landmark Trace IV (Adjusted)
            20: { s3: 90, s2: 120 },  // Sequential Memory: Landmark Trace V (Adjusted)
            21: { s3: 100, s2: 130 }, // Sequential Memory: Landmark Trace VI (Adjusted)
            22: { s3: 60, s2: 80 },   // Risk & Decision: Hazard Breakout I (Adjusted)
            23: { s3: 80, s2: 110 },  // Risk & Decision: Hazard Breakout II (Adjusted)
            24: { s3: 100, s2: 140 }, // Risk & Decision: Hazard Breakout III (Adjusted)
            25: { s3: 120, s2: 160 }, // Risk & Decision: Hazard Breakout IV (Adjusted)
            26: { s3: 150, s2: 200 }, // Risk & Decision: Hazard Breakout V (Adjusted)
        };
        const TOTAL_LEVELS = 27;

        // --- UI Elements ---
        let instructionElement, blockerElement, crosshairElement, npcCounterElement, landmarkCounterElement, genericCounterElement, mapUsesCounterElement;
        let menuOverlay, levelSelectMenu, modeSelectionScreen, playerInfoElement;
        let keyDisplay, keyW, keyA, keyS, keyD, keySpace, keyShift;
        let narrationBox, resultsOverlay, trainingChoiceOverlay, trainingCommandElement, resetConfirmOverlay;
        let warmupConfirmOverlay; 
        let healthContainer, healthBar, healthText;

        // --- Stage Specific Variables ---
        let stageObjects = [];
        let collidables = [];
        let animatedObjects = [];
        let npcs = [];
        let landmarks = [];
        let turrets = [];
        let nextLandmarkIndex = 0;
        const raycaster = new THREE.Raycaster();
        const centerScreen = new THREE.Vector2(0, 0);
        let stage1Targets = [];
        let aimedTargets = new Set();
        let stageCompletionFlag = false; 
        let isTransitioning = false;
        let highlightedRing = null;
        
        let shuttleRunState = {};
        let shuttleRunMaterials = {};
        let trailParticles = []; 

        let corridorState = {};
        let corridorTargets = [];
        let activatedCorridorTargets = new Set();

        let wasdTrainingKeys = [];
        let wasdCenterButton = null;
        let wasdTrainingActivated = false;
        let wasdTrainingMode = null; 
        let currentTrainingKey = null; 
        let isWaitingForNextCommand = false;

        let toyGun;
        let bullets = [];
        let bulletHoles = [];
        let shootCooldown = 0;

        let levelStartTime = 0;
        let timePausedAt = 0;
        let isTimerRunning = false;
        let timerElement;
        let minimapContainer, minimap, minimapCtx;
        let firework3DParticles = [];
        let fireworksInterval = null;
        let minimapUsesLeft = 8; 
        
        let warmupCountdownInterval = null;
        let warmupTimerDisplayElement;

        let stonePathTexture, metallicPatternFloorTexture, shuttleRunStoneTexture, shuttleRunMetalTexture;
        let shuttleRunFloorTexture, missionCorridorFloorTexture;
        let mazeWallMaterial, shuttleRunWallMaterials;

        window.onload = function() {
            init();
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, 150);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = playerHeight;

            createToyGun();
            camera.add(toyGun);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            instructionElement = document.getElementById('instructions');
            blockerElement = document.getElementById('blocker');
            crosshairElement = document.getElementById('crosshair');
            npcCounterElement = document.getElementById('npc-counter');
            landmarkCounterElement = document.getElementById('landmark-counter');
            genericCounterElement = document.getElementById('generic-counter');
            mapUsesCounterElement = document.getElementById('map-uses-counter'); 
            menuOverlay = document.getElementById('menu-overlay');
            levelSelectMenu = document.getElementById('level-select-menu');
            modeSelectionScreen = document.getElementById('mode-selection');
            playerInfoElement = document.getElementById('player-info');
            keyDisplay = document.getElementById('key-display');
            keyW = document.getElementById('key-w');
            keyA = document.getElementById('key-a');
            keyS = document.getElementById('key-s');
            keyD = document.getElementById('key-d');
            keySpace = document.getElementById('key-space');
            keyShift = document.getElementById('key-shift');
            timerElement = document.getElementById('timer');
            minimapContainer = document.getElementById('minimap-container');
            minimap = document.getElementById('minimap');
            minimap.width = 200;
            minimap.height = 200;
            minimapCtx = minimap.getContext('2d');
            narrationBox = document.getElementById('narration-box');
            resultsOverlay = document.getElementById('results-overlay');
            trainingChoiceOverlay = document.getElementById('training-choice-overlay');
            trainingCommandElement = document.getElementById('training-command');
            resetConfirmOverlay = document.getElementById('reset-confirm-overlay');
            warmupConfirmOverlay = document.getElementById('warmup-confirm-overlay');
            warmupTimerDisplayElement = document.getElementById('warmup-timer-display');
            healthContainer = document.getElementById('player-health-container');
            healthBar = document.getElementById('player-health-bar');
            healthText = document.getElementById('player-health-text');

            playerVelocity = new THREE.Vector3();

            createTexturesAndMaterials();
            setupModeSelection();
            setupMenu();
            setupResultsScreen();
            setupTrainingChoice();
            setupResetConfirmation();
            setupWarmupConfirmation(); 
            document.addEventListener('pointerlockchange', onPointerlockChange, false);
            document.addEventListener('pointerlockerror', onPointerlockError, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onMouseDown, false);

            animate();
        }

        function loadProgress() {
            if (gameMode === 'campaign') {
                const savedUnlockedLevel = localStorage.getItem('unlockedLevel');
                unlockedLevel = savedUnlockedLevel ? parseInt(savedUnlockedLevel, 10) : 1;
                const savedLevelTimes = localStorage.getItem('levelTimes_campaign');
                levelTimes = savedLevelTimes ? JSON.parse(savedLevelTimes) : {};
                const savedStars = localStorage.getItem('levelStars');
                levelStars = savedStars ? JSON.parse(savedStars) : {};
            } else {
                const savedLevelTimes = localStorage.getItem('levelTimes_free');
                levelTimes = savedLevelTimes ? JSON.parse(savedLevelTimes) : {};
            }
        }

        function saveProgress() {
            if (gameMode === 'campaign') {
                localStorage.setItem('unlockedLevel', unlockedLevel);
                localStorage.setItem('levelTimes_campaign', JSON.stringify(levelTimes));
                localStorage.setItem('levelStars', JSON.stringify(levelStars));
            } else {
                localStorage.setItem('levelTimes_free', JSON.stringify(levelTimes));
            }
        }
        
        function recordTime(stage, time) {
            const stageId = stage;
            if (!levelTimes[stageId] || time < levelTimes[stageId]) {
                levelTimes[stageId] = time;
            }
        }

        function setupModeSelection() {
            document.getElementById('campaign-mode-button').addEventListener('click', () => {
                gameMode = 'campaign';
                const savedProfile = localStorage.getItem('playerProfile');
                if (savedProfile) {
                    playerProfile = JSON.parse(savedProfile);
                    startGame();
                } else {
                    modeSelectionScreen.style.display = 'none';
                    document.getElementById('profile-creation-overlay').style.display = 'flex';
                }
            });
            document.getElementById('free-mode-button').addEventListener('click', () => { 
                gameMode = 'free'; 
                startGame(); 
            });
            setupProfileCreation();
        }

        function setupProfileCreation() {
            const nicknameInput = document.getElementById('nickname-input');
            const maleButton = document.getElementById('male-button');
            const femaleButton = document.getElementById('female-button');
            const startButton = document.getElementById('start-campaign-button');
            let selectedGender = '';

            maleButton.addEventListener('click', () => {
                selectedGender = 'male';
                maleButton.classList.add('selected');
                femaleButton.classList.remove('selected');
            });

            femaleButton.addEventListener('click', () => {
                selectedGender = 'female';
                femaleButton.classList.add('selected');
                maleButton.classList.remove('selected');
            });

            startButton.addEventListener('click', () => {
                const nickname = nicknameInput.value.trim();
                if (!nickname) {
                    nicknameInput.style.border = '2px solid red';
                    return;
                }
                 nicknameInput.style.border = '2px solid #555';
                if (!selectedGender) {
                    maleButton.style.border = '2px solid red';
                    femaleButton.style.border = '2px solid red';
                    return;
                }
                playerProfile.nickname = nickname;
                playerProfile.title = selectedGender === 'male' ? `${nickname} 叔叔` : `${nickname} 阿姨`;
                localStorage.setItem('playerProfile', JSON.stringify(playerProfile));
                document.getElementById('profile-creation-overlay').style.display = 'none';
                startGame();
            });
        }
        
        function startGame() {
            loadProgress();
            modeSelectionScreen.style.display = 'none';
            loadStage(0);
        }

        function setupMenu() {
            blockerElement.addEventListener('click', () => {
                if (isPlayerDead) return;
                if (stageCompletionFlag) {
                    if (gameMode === 'campaign' && currentStage < TOTAL_LEVELS) {
                         hideMenuAndLoad(currentStage + 1);
                    } else {
                        stageCompletionFlag = false;
                        blockerElement.style.display = 'none';
                        menuOverlay.style.display = 'flex';
                        updateLevelSelectMenu();
                    }
                    return;
                }
                document.body.requestPointerLock();
            });
            document.getElementById('resume-button').addEventListener('click', () => { document.body.requestPointerLock(); });
            document.getElementById('restart-button').addEventListener('click', () => { hideMenuAndLoad(currentStage); });
            document.getElementById('warmup-button').addEventListener('click', () => { hideMenuAndLoad(0); });
            document.getElementById('main-menu-button').addEventListener('click', () => {
                if (document.pointerLockElement) document.exitPointerLock();
                currentStage = -1;
                stopTimer();
                menuOverlay.style.display = 'none';
                modeSelectionScreen.style.display = 'flex';
                if (playerInfoElement) playerInfoElement.style.display = 'none';
            });
            document.getElementById('select-level-button').addEventListener('click', (event) => {
                event.stopPropagation();
                levelSelectMenu.style.display = levelSelectMenu.style.display === 'flex' ? 'none' : 'flex';
            });
            document.getElementById('reset-game-button').addEventListener('click', () => {
                resetConfirmOverlay.style.display = 'flex';
            });
        }
        
        function setupResultsScreen() {
            document.getElementById('close-results-button').addEventListener('click', () => {
                resultsOverlay.style.display = 'none';
                const mainMenuButton = document.getElementById('main-menu-button');
                if (mainMenuButton) mainMenuButton.click();
            });
        }
        
        function setupTrainingChoice() {
            document.getElementById('training-yes').addEventListener('click', () => {
                wasdTrainingMode = 'special';
                trainingChoiceOverlay.style.display = 'none';
                document.body.requestPointerLock();
                startNextTrainingCommand();
            });
            document.getElementById('training-no').addEventListener('click', () => {
                wasdTrainingMode = 'free';
                trainingChoiceOverlay.style.display = 'none';
                document.body.requestPointerLock();
            });
        }

        function setupResetConfirmation() {
            document.getElementById('reset-confirm-no').addEventListener('click', () => {
                resetConfirmOverlay.style.display = 'none';
            });
            document.getElementById('reset-confirm-yes').addEventListener('click', () => {
                localStorage.removeItem('playerProfile');
                localStorage.removeItem('unlockedLevel');
                localStorage.removeItem('levelTimes_campaign');
                localStorage.removeItem('levelStars');
                
                playerProfile = { nickname: '', title: '' };
                unlockedLevel = 1;
                levelTimes = {};
                levelStars = {};

                resetConfirmOverlay.style.display = 'none';
                document.getElementById('main-menu-button').click();
            });
        }

        function setupWarmupConfirmation() {
            document.getElementById('warmup-confirm-yes').addEventListener('click', () => {
                warmupConfirmOverlay.style.display = 'none';
                hideMenuAndLoad(1);
            });
            document.getElementById('warmup-confirm-no').addEventListener('click', () => {
                warmupConfirmOverlay.style.display = 'none';
                document.body.requestPointerLock();
            });
        }

        function updateLevelSelectMenu() {
            // --- UPDATED: New Level Names based on Cognitive Training ---
            const stageNames = [
                { zh: "注意力：定点聚焦", en: "Attention: Point Focus" },
                { zh: "反应速度：瞬时响应", en: "Reaction: Quick Response" },
                { zh: "处理速度：动态追踪", en: "Processing: Dynamic Tracking" },
                { zh: "预判能力：轨迹预测", en: "Prediction: Trajectory Forecast" },
                { zh: "手眼协调：同步处理", en: "Coordination: Synchronized Tasks" },
                { zh: "空间规划：蓝图导航", en: "Spatial Planning: Blueprint Navigation" },
                { zh: "动作规划：节奏跨越", en: "Motor Skills: Rhythmic Leap" },
                { zh: "认知灵活性：任务切换", en: "Cognitive Flexibility: Task Switching" },
                { zh: "工作记忆：迷宫速通 I", en: "Working Memory: Maze Sprint I" },
                { zh: "工作记忆：迷宫速通 II", en: "Working Memory: Maze Sprint II" },
                { zh: "工作记忆：迷宫速通 III", en: "Working Memory: Maze Sprint III" },
                { zh: "工作记忆：迷宫速通 IV", en: "Working Memory: Maze Sprint IV" },
                { zh: "策略思维：动态博弈 I", en: "Strategic Thinking: Dynamic Chase I" },
                { zh: "策略思维：动态博弈 II", en: "Strategic Thinking: Dynamic Chase II" },
                { zh: "策略思维：动态博弈 III", en: "Strategic Thinking: Dynamic Chase III" },
                { zh: "顺序记忆：地标寻踪 I", en: "Sequential Memory: Landmark Trace I" },
                { zh: "顺序记忆：地标寻踪 II", en: "Sequential Memory: Landmark Trace II" },
                { zh: "顺序记忆：地标寻踪 III", en: "Sequential Memory: Landmark Trace III" },
                { zh: "顺序记忆：地标寻踪 IV", en: "Sequential Memory: Landmark Trace IV" },
                { zh: "顺序记忆：地标寻踪 V", en: "Sequential Memory: Landmark Trace V" },
                { zh: "顺序记忆：地标寻踪 VI", en: "Sequential Memory: Landmark Trace VI" },
                { zh: "风险决策：火线突围 I", en: "Risk & Decision: Hazard Breakout I" },
                { zh: "风险决策：火线突围 II", en: "Risk & Decision: Hazard Breakout II" },
                { zh: "风险决策：火线突围 III", en: "Risk & Decision: Hazard Breakout III" },
                { zh: "风险决策：火线突围 IV", en: "Risk & Decision: Hazard Breakout IV" },
                { zh: "风险决策：火线突围 V", en: "Risk & Decision: Hazard Breakout V" },
                { zh: "综合能力认证", en: "Cognitive Mastery" }
            ];
            levelSelectMenu.innerHTML = ''; 
            stageNames.forEach((name, i) => {
                const stageIndex = i + 1;
                const button = document.createElement('button');
                button.className = 'menu-button';
                const isLocked = gameMode === 'campaign' && stageIndex > unlockedLevel;
                let buttonHTML = `${name.zh}<br><span style="font-size:12px;">${name.en}</span>`;
                if (isLocked) {
                    buttonHTML += ' <br><span style="font-size:12px; color: #888;">(锁定 / Locked)</span>';
                    button.classList.add('disabled');
                } else {
                    const bestTime = levelTimes[stageIndex];
                    if (bestTime) { buttonHTML += `<div class="level-time">最快 / Best: ${bestTime.toFixed(2)}s</div>`; }
                    if (gameMode === 'campaign' && levelStars[stageIndex]) {
                         buttonHTML += `<div class="level-stars">${displayStars(levelStars[stageIndex])}</div>`;
                    }
                    button.addEventListener('click', (event) => { event.stopPropagation(); hideMenuAndLoad(stageIndex); });
                }
                button.innerHTML = buttonHTML;
                levelSelectMenu.appendChild(button);
            });
        }

        function hideMenuAndLoad(stage) {
            menuOverlay.style.display = 'none';
            levelSelectMenu.style.display = 'none';
            isTransitioning = true;
            if (document.pointerLockElement) { document.exitPointerLock(); }
            setTimeout(() => { loadStage(stage); }, 100);
        }

        function onPointerlockChange() {
            if (document.pointerLockElement === document.body) {
                isTransitioning = false; 
                menuOverlay.style.display = 'none';
                blockerElement.style.display = 'none';
                crosshairElement.style.display = 'block';
                keyDisplay.style.opacity = '1';
                document.addEventListener('mousemove', onMouseMove, false);
                resumeTimer();
            } else {
                crosshairElement.style.display = 'none';
                keyDisplay.style.opacity = '0';
                document.removeEventListener('mousemove', onMouseMove, false);
                pauseTimer();
                if (!isTransitioning && !stageCompletionFlag && !isPlayerDead && resultsOverlay.style.display !== 'flex' && trainingChoiceOverlay.style.display !== 'flex' && resetConfirmOverlay.style.display !== 'flex' && warmupConfirmOverlay.style.display !== 'flex') {
                    menuOverlay.style.display = 'flex';
                    document.getElementById('reset-game-button').style.display = (gameMode === 'campaign') ? 'inline-block' : 'none';
                    updateLevelSelectMenu();
                }
            }
        }

        function onPointerlockError() { console.error('Pointer Lock Error.'); }
        
        function onMouseMove(event) {
            if (document.pointerLockElement !== document.body) return;
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            if (Math.abs(movementX) > 500 || Math.abs(movementY) > 500) { return; }
            euler.setFromQuaternion(camera.quaternion);
            euler.y -= movementX * 0.002;
            euler.x -= movementY * 0.002;
            euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
            camera.quaternion.setFromEuler(euler);
        }

        function onMouseDown(event) {
            if (narrationBox.style.display === 'block') {
                narrationBox.style.display = 'none';
                return;
            }
            if (isPlayerDead) return;

            if (currentStage === 0 && wasdTrainingMode === 'special') {
                wasdTrainingMode = 'free';
                trainingCommandElement.style.display = 'none';
                currentTrainingKey = null;
                isWaitingForNextCommand = false;
                showNarration('已取消移动特训。<br>Canceled special training.');
                return;
            }

            if (document.pointerLockElement === document.body && toyGun.visible && shootCooldown <= 0) {
                handleShooting();
            }
        }

        function loadStage(stageIndex) {
            if (fireworksInterval) { clearInterval(fireworksInterval); fireworksInterval = null; }
            if (warmupCountdownInterval) { clearInterval(warmupCountdownInterval); warmupCountdownInterval = null; }
            if (warmupTimerDisplayElement) warmupTimerDisplayElement.style.display = 'none';
            if (warmupConfirmOverlay) warmupConfirmOverlay.style.display = 'none';

            scene.background.set(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, 150);

            currentStage = stageIndex;
            stageCompletionFlag = false; 
            hasPlayerMoved = false;
            canPlayerMove = true;
            isPlayerDead = false;
            
            playerHealth = maxPlayerHealth;
            updateHealthBar();
            const isTurretLevel = (currentStage >= 22 && currentStage <= 26);
            healthContainer.style.display = isTurretLevel ? 'block' : 'none';
            if (toyGun) toyGun.visible = (stageIndex === 0 || isTurretLevel);
            
            crosshairElement.className = isTurretLevel ? 'crosshair-turret' : 'crosshair-default';

            const childrenToRemove = scene.children.filter(child => child !== camera);
            childrenToRemove.forEach(child => {
                child.traverse(object => {
                    if (object.isMesh) {
                        if (object.geometry) object.geometry.dispose();
                    }
                });
                scene.remove(child);
            });

            stageObjects = []; collidables = []; npcs = []; landmarks = []; turrets = [];
            animatedObjects = [];
            bullets = []; bulletHoles = []; firework3DParticles = []; trailParticles = []; 
            stage1Targets = []; aimedTargets.clear();
            shuttleRunState = {}; corridorState = {}; corridorTargets = []; activatedCorridorTargets.clear();
            wasdTrainingKeys = []; 
            wasdTrainingActivated = false;
            wasdCenterButton = null;
            wasdTrainingMode = null;
            currentTrainingKey = null;
            isWaitingForNextCommand = false;
            npcCounterElement.style.display = 'none';
            landmarkCounterElement.style.display = 'none';
            genericCounterElement.style.display = 'none';
            mapUsesCounterElement.style.display = 'none'; 
            scene.userData = {}; 
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(-25, 35, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);
            
            const isMinimapVisible = (currentStage === 6 || (currentStage >= 9 && currentStage <= 26));
            minimapContainer.style.display = isMinimapVisible ? 'block' : 'none';
            
            playerVelocity.set(0, 0, 0);
            isCrouching = false; 
            playerOnFloor = true; 
            
            resultsOverlay.style.display = 'none';
            trainingChoiceOverlay.style.display = 'none';
            trainingCommandElement.style.display = 'none';

            switch(currentStage) {
                case 0: setupStage0_Warmup(); break;
                case 1: setupStage1_Look(); break;
                case 2: setupStage3_ShuttleRun_Static(); break;
                case 3: setupStage4_ShuttleRun_Moving(); break;
                case 4: setupStage5_ShuttleRun_HighSpeed(); break;
                case 5: setupStage6_MissionCorridor(); break;
                case 6: setupStage7_Move(); break;
                case 7: setupStage8_Jump(); break;
                case 8: setupStage9_Skills(); break;
                case 9: setupStage10_Timed0(); break;
                case 10: setupStage11_Timed1(); break;
                case 11: setupStage12_Timed2(); break;
                case 12: setupStage13_Timed3(); break;
                case 13: setupStage14_Chase1(); break;
                case 14: setupStage15_Chase2(); break;
                case 15: setupStage16_Chase3(); break;
                case 16: setupStage17_Landmark1(); break;
                case 17: setupStage17_Landmark1_2(); break;
                case 18: setupStage18_Landmark2(); break;
                case 19: setupStage18_Landmark2_2(); break;
                case 20: setupStage19_Landmark3(); break;
                case 21: setupStage19_Landmark3_2(); break;
                case 22: setupStage22_TurretMaze1(); break;
                case 23: setupStage23_TurretMaze2(); break;
                case 24: setupStage24_TurretMaze3(); break;
                case 25: setupStage25_TurretMaze4(); break;
                case 26: setupStage26_TurretMaze5(); break;
                case 27: setupStage_Final(); break; 
            }

            if (currentStage !== TOTAL_LEVELS) {
                updateInstructions();
                blockerElement.style.display = 'flex';
                instructionElement.style.display = 'block';
            }
            
            updatePlayerInfoUI();
            stopTimer();
            if (isTimedLevel(currentStage)) {
                timerElement.style.display = 'block';
                timerElement.textContent = "0.00s";
            }
        }
        
        function isTimedLevel(stage) { return stage > 0 && stage < TOTAL_LEVELS; }

        function getStarRating(stage, time) {
            const thresholds = starTimeThresholds[stage];
            if (!thresholds) return 1;
            if (time <= thresholds.s3) return 3;
            if (time <= thresholds.s2) return 2;
            return 1;
        }

        function displayStars(starCount) {
            let starsHTML = '';
            for (let i = 0; i < 3; i++) {
                starsHTML += `<span class="${i < starCount ? 'star-filled' : 'star-empty'}">★</span>`;
            }
            return starsHTML;
        }

        function updatePlayerInfoUI() {
            if (!playerInfoElement) return;
            if (gameMode === 'campaign' && currentStage > 0 && currentStage < TOTAL_LEVELS) {
                const playerNameElement = document.getElementById('player-name');
                const playerStarsElement = document.getElementById('player-stars');
                playerNameElement.textContent = playerProfile.title;
                const currentStars = Object.values(levelStars).reduce((sum, stars) => sum + stars, 0);
                const totalStars = Object.keys(starTimeThresholds).length * 3;
                playerStarsElement.innerHTML = `星星 / Stars: ${currentStars} / ${totalStars} <span class="star-filled">★</span>`;
                playerInfoElement.style.display = 'block';
            } else {
                playerInfoElement.style.display = 'none';
            }
        }

        function updateInstructions() {
            let text = "";
            const enStyle = `font-size: 14px; color: #ccc;`;
            const clickContinueStyle = `font-size: 16px; margin-top: 20px; text-align: center; color: #ffdd57;`;
            const starContainer = document.getElementById('star-container');
            const instructionTextElement = document.getElementById('instruction-text');
            if (!instructionTextElement || !starContainer) return;
            starContainer.innerHTML = ''; 

            if (isPlayerDead) {
                 text = `您已被击败！<br><br><span style="${enStyle}">You have been defeated!</span><br><br><div style="${clickContinueStyle}">点击以重新开始 / Click to Restart</div>`;
            } else if (stageCompletionFlag) {
                const elapsedTime = (clock.getElapsedTime() - levelStartTime);
                let continueText;
                if (gameMode === 'campaign') {
                    const stars = levelStars[currentStage] || 1;
                    starContainer.innerHTML = displayStars(stars);
                    continueText = (currentStage < TOTAL_LEVELS) ? "点击进入下一关 / Click for Next Level" : "点击查看最终认证 / Click for Final Results";
                    text = `太棒了, ${playerProfile.title}！<br>训练完成！<br>用时: **${elapsedTime.toFixed(2)}** 秒<br><br><span style="${enStyle}">Great job, ${playerProfile.title}!<br>Training Complete!<br>Time: **${elapsedTime.toFixed(2)}** seconds</span><br><br><div style="${clickContinueStyle}">${continueText}</div>`;
                } else { 
                    recordTime(currentStage, elapsedTime);
                    continueText = "点击返回菜单 / Click to Return to Menu";
                    text = `训练完成！<br>用时: **${elapsedTime.toFixed(2)}** 秒<br><br><span style="${enStyle}">Training Complete!<br>Time: **${elapsedTime.toFixed(2)}** seconds</span><br><br><div style="${clickContinueStyle}">${continueText}</div>`;
                }
            } else {
                let greeting = gameMode === 'campaign' && playerProfile.title ? `你好, ${playerProfile.title}。<br><span style="${enStyle}">Hello, ${playerProfile.title}.</span><br>` : '';
                switch(currentStage) {
                    case 0: text = `欢迎来到认知热身！<br>请熟悉 **WASD** 移动, **空格** 跳跃, **Shift** 下蹲。<br>用准星瞄准靶子, **点击鼠标左键** 射击。<br>熟悉后按 **ESC** 打开菜单进入训练。<br><br><span style="${enStyle}">Welcome to Cognitive Warm-up!<br>Use **WASD** to move, **Space** to jump, and **Shift** to crouch. Aim at targets and **Left-click** to shoot.<br>Press **ESC** to open the menu when ready.</span>`; break;
                    case 1: text = `${greeting}**注意力训练：定点聚焦**<br>请用准星瞄准所有 **红色** 目标。<br>已找到: ${aimedTargets.size} / 4<br><br><span style="${enStyle}">**Attention: Point Focus**<br>Aim at all **red** targets.<br>Found: ${aimedTargets.size} / 4</span>`; break;
                    case 2: text = `${greeting}**反应速度训练：瞬时响应**<br>请快速移动到亮起的 **红色** 目标处。<br>已完成: ${shuttleRunState.completedCount || 0} / 10<br><br><span style="${enStyle}">**Reaction: Quick Response**<br>Quickly move to the lit **red** target.<br>Completed: ${shuttleRunState.completedCount || 0} / 10</span>`; break;
                    case 3: text = `${greeting}**处理速度训练：动态追踪**<br>请追上并触碰移动的 **红色** 目标。<br>已完成: ${shuttleRunState.completedCount || 0} / 10<br><br><span style="${enStyle}">**Processing: Dynamic Tracking**<br>Chase and touch the moving **red** target.<br>Completed: ${shuttleRunState.completedCount || 0} / 10</span>`; break;
                    case 4: text = `${greeting}**预判能力训练：轨迹预测**<br>请预判并拦截高速移动的 **红色** 目标。<br>已完成: ${shuttleRunState.completedCount || 0} / 10<br><br><span style="${enStyle}">**Prediction: Trajectory Forecast**<br>Predict and intercept the fast-moving **red** target.<br>Completed: ${shuttleRunState.completedCount || 0} / 10</span>`; break;
                    case 5: text = `${greeting}**手眼协调训练：同步处理**<br>请在前进中用准星激活所有 **红色** 目标，并抵达终点。<br>已激活: ${activatedCorridorTargets.size} / ${corridorState.allTargets?.length || 0}<br><br><span style="${enStyle}">**Coordination: Synchronized Tasks**<br>Activate all **red** targets while moving and reach the end.<br>Activated: ${activatedCorridorTargets.size} / ${corridorState.allTargets.length || 0}</span>`; break;
                    case 6: text = `${greeting}**空间规划训练：蓝图导航**<br>请参考 **小地图** 的路线指引，找到终点。<br><br><span style="${enStyle}">**Spatial Planning: Blueprint Navigation**<br>Follow the route on the **minimap** to find the goal.</span>`; break;
                    case 7: text = `${greeting}**动作规划训练：节奏跨越**<br>请按下 **空格键**，按节奏跳过障碍，抵达终点。<br><br><span style="${enStyle}">**Motor Skills: Rhythmic Leap**<br>Press **Spacebar** to rhythmically jump over the obstacles to the goal.</span>`; break;
                    case 8: text = `${greeting}**认知灵活性训练：任务切换**<br>请综合运用**跳跃**和**下蹲(Shift)**穿过障碍，抵达终点。<br><br><span style="${enStyle}">**Cognitive Flexibility: Task Switching**<br>Use both **jumping** and **crouching (Shift)** to get to the goal.</span>`; break;
                    case 9: case 10: case 11: case 12: text = `${greeting}**工作记忆训练：迷宫速通 ${currentStage - 8}**<br>用最快的速度抵达终点！<br><br><span style="${enStyle}">**Working Memory: Maze Sprint ${currentStage - 8}**<br>Get to the finish line as fast as you can!</span>`; break;
                    case 13: case 14: case 15: text = `${greeting}**策略思维训练：动态博弈 ${currentStage - 12}**<br>迷宫里出现了动态目标！**在它们跑掉前捉住它们**！<br><br><span style="${enStyle}">**Strategic Thinking: Dynamic Chase ${currentStage - 12}**<br>Dynamic targets have appeared! **Catch them**!</span>`; break;
                    case 16: case 17: case 18: case 19: case 20: case 21: text = `${greeting}**顺序记忆训练：地标寻踪**<br>请按顺序找到所有地标！<br>移动后小地图会消失，按 **E键** 可暂停并查看地图（有次数限制）。<br><br><span style="${enStyle}">**Sequential Memory: Landmark Trace**<br>Find all landmarks in order!<br>Minimap disappears on move. Press **E** to pause and view map (limited uses).</span>`; break;
                    case 22: case 23: case 24: case 25: case 26: text = `${greeting}**风险决策训练：火线突围**<br>找到所有地标，同时要小心**防御塔**！<br>摧毁它们可以恢复1点HP并增加1次地图使用次数，也可以选择躲开攻击！<br><br><span style="${enStyle}">**Risk & Decision: Hazard Breakout**<br>Find all landmarks, but watch out for **turrets**!<br>Destroying them restores 1 HP and grants 1 map use. You can also evade their fire!</span>`; break;
                    case 27: text = ``; break;
                    default: text = `点击鼠标左键开始<br><span style="font-size:12px;">Left Click to Start</span>`; break;
                }
            }
            instructionTextElement.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<span style="color: #ffdd57;">$1</span>');
        }


        function pauseTimer() { if (isTimerRunning) { isTimerRunning = false; timePausedAt = clock.getElapsedTime(); } }
        function resumeTimer() { if (isTimedLevel(currentStage)) { if (!isTimerRunning) { if (levelStartTime === 0) { levelStartTime = clock.getElapsedTime(); } else { const pauseDuration = clock.getElapsedTime() - timePausedAt; levelStartTime += pauseDuration; } isTimerRunning = true; } } }
        function stopTimer() { isTimerRunning = false; levelStartTime = 0; timePausedAt = 0; if (isTimedLevel(currentStage)) { timerElement.style.display = 'none'; } }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const totalTime = clock.getElapsedTime();

            if (shootCooldown > 0) shootCooldown -= deltaTime;

            if (currentStage >= 2 && currentStage <= 4) {
                updateShuttleRunTargets(deltaTime);
            }
            if (currentStage >= 22 && currentStage <= 26) {
                updateTurrets(deltaTime);
            }

            animatedObjects.forEach(obj => {
                if (obj.userData.animation) {
                    obj.userData.animation(totalTime, deltaTime);
                }
            });

            updateBullets(deltaTime);
            updateBulletHoles(deltaTime);
            update3DFireworks(deltaTime);
            updateTrailParticles(deltaTime); 

            if (isTimerRunning) { const elapsedTime = clock.getElapsedTime() - levelStartTime; timerElement.textContent = elapsedTime.toFixed(2) + 's'; }
            
            if (minimapContainer.style.display === 'block') drawMinimap(); 
            
            if (document.pointerLockElement === document.body && !isPlayerDead) {
                updatePlayer(deltaTime);
                if (currentStage === 0) { 
                    handleWarmupAiming(); 
                    updateWasdTraining();
                }
                if (currentStage === 1) handleAiming();
                if (currentStage === 5) handleCorridorAiming();
                if (currentStage >= 13 && currentStage <= 15 && npcs.length > 0) npcs.forEach(npc => updateNPC(npc, deltaTime));
                checkStageCompletion();
                updateKeyDisplay();
            }

            if (camera.position.y < -30 && !isTransitioning) {
                handlePlayerDeath();
            }

            renderer.render(scene, camera);
        }

        function checkStageCompletion() {
            if (stageCompletionFlag || isTransitioning || isPlayerDead) return;
            let shouldAdvance = false;
            const playerPos = camera.position;
            switch(currentStage) {
                case 1: if (stage1Targets.length > 0 && aimedTargets.size === stage1Targets.length) shouldAdvance = true; break;
                case 2: case 3: case 4:
                    if (shuttleRunState.activeTarget) {
                        if (playerPos.distanceTo(shuttleRunState.activeTarget.position) < 2.0) {
                            create3DFirework(shuttleRunState.activeTarget.position);
                            shuttleRunState.activeTarget.material = shuttleRunMaterials.yellow;
                            shuttleRunState.completedCount++;
                            updateGenericCounter(`已完成: ${shuttleRunState.completedCount} / 10`);
                            updateInstructions();
                            if (shuttleRunState.completedCount >= shuttleRunState.targets.length) {
                                shouldAdvance = true;
                            } else {
                                activateNextShuttleTarget();
                            }
                        }
                    }
                    break;
                case 5:
                    const finishFlag5 = scene.getObjectByName("finish_flag");
                    const allTargetsHit = activatedCorridorTargets.size === corridorState.allTargets.length;
                    const playerAtEnd = finishFlag5 && playerPos.distanceTo(finishFlag5.position) < 3;
                    if (allTargetsHit && playerAtEnd) {
                        shouldAdvance = true;
                    }
                    break;
                case 6: 
                    const target6 = scene.getObjectByName("finish_flag");
                    if (target6 && playerPos.distanceTo(target6.position) < 3) shouldAdvance = true;
                    break;
                case 7: if (playerPos.z < -18) shouldAdvance = true; break;
                case 8: if (playerPos.z < -23) shouldAdvance = true; break;
                case 9: case 10: case 11: case 12:
                    const endPos = scene.userData.endPos;
                    if (endPos && playerPos.distanceTo(endPos) < 4) shouldAdvance = true;
                    break;
                case 13: case 14: case 15:
                    const playerPos2D = new THREE.Vector2(playerPos.x, playerPos.z);
                    for (let i = npcs.length - 1; i >= 0; i--) {
                        const npc = npcs[i];
                        if (playerPos2D.distanceTo(new THREE.Vector2(npc.position.x, npc.position.z)) < 2.5) {
                            scene.remove(npc); npcs.splice(i, 1); updateNpcCounter();
                        }
                    }
                    if (npcs.length === 0) shouldAdvance = true;
                    break;
                case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26:
                    if (landmarks.length > 0 && nextLandmarkIndex < landmarks.length) {
                        const nextLandmark = landmarks[nextLandmarkIndex];
                        if (!nextLandmark.userData.isFound && playerPos.distanceTo(nextLandmark.position) < 3) {
                            nextLandmark.material.color.setHex(0x00ff00);
                            nextLandmark.material.emissive.setHex(0x008800);
                            nextLandmark.userData.isFound = true;
                            create3DFirework(nextLandmark.position);
                            nextLandmarkIndex++;
                            updateLandmarkCounter();
                            if (nextLandmarkIndex === landmarks.length) shouldAdvance = true;
                        }
                    }
                    break;
            }

            if (shouldAdvance) {
                stageCompletionFlag = true;
                pauseTimer();
                const elapsedTime = (clock.getElapsedTime() - levelStartTime);
                if (gameMode === 'campaign') {
                    if (currentStage >= unlockedLevel) {
                         unlockedLevel = Math.min(currentStage + 1, TOTAL_LEVELS + 1);
                    }
                    const newStars = getStarRating(currentStage, elapsedTime);
                    if (!levelStars[currentStage] || newStars > levelStars[currentStage]) {
                        levelStars[currentStage] = newStars;
                    }
                    recordTime(currentStage, elapsedTime); 
                    saveProgress(); 
                    updatePlayerInfoUI();
                } else {
                    recordTime(currentStage, elapsedTime);
                    saveProgress();
                }
                updateInstructions();
                blockerElement.style.display = 'flex';
                if (document.pointerLockElement) { isTransitioning = true; document.exitPointerLock(); }
            }
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        
        function onKeyDown(event) {
            keys[event.code] = true;
            if (event.code === 'Escape') { 
                if (document.pointerLockElement === document.body) document.exitPointerLock();
            }
            if (event.code === 'KeyE' && (currentStage >= 16 && currentStage <= 26)) {
                if (minimapUsesLeft > 0) {
                    if (minimapContainer.style.display === 'none') { 
                        minimapUsesLeft--;
                        updateMapUsesCounter();
                    }
                    canPlayerMove = false;
                    minimapContainer.style.display = 'block';
                } else {
                    if (minimapContainer.style.display === 'none') { 
                         showNarration('地图使用次数已用完！<br>No map uses left!');
                    }
                }
            }
        }

        function onKeyUp(event) {
            keys[event.code] = false;
            if (event.code === 'KeyE' && (currentStage >= 16 && currentStage <= 26)) {
                canPlayerMove = true;
                if (hasPlayerMoved) minimapContainer.style.display = 'none';
            }
        }

        // --- Helper Functions ---
        function createTexturesAndMaterials() {
            let canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            let ctx = canvas.getContext('2d');
            ctx.fillStyle = '#555555';
            ctx.fillRect(0, 0, 512, 512);
            let imageData = ctx.getImageData(0, 0, 512, 512);
            let data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const randomFactor = (Math.random() - 0.5) * 30;
                data[i]   += randomFactor;
                data[i+1] += randomFactor;
                data[i+2] += randomFactor;
            }
            ctx.putImageData(imageData, 0, 0);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 512; i += 64) {
                for (let j = 0; j < 512; j += 64) {
                    ctx.beginPath();
                    ctx.arc(i + 32, j + 32, 32, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            stonePathTexture = new THREE.CanvasTexture(canvas);
            stonePathTexture.wrapS = THREE.RepeatWrapping;
            stonePathTexture.wrapT = THREE.RepeatWrapping;

            canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            ctx = canvas.getContext('2d');
            ctx.fillStyle = '#404050';
            ctx.fillRect(0, 0, 512, 512);
            imageData = ctx.getImageData(0, 0, 512, 512);
            data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const randomFactor = (Math.random() - 0.5) * 15;
                data[i] += randomFactor;
                data[i+1] += randomFactor;
                data[i+2] += randomFactor;
            }
            ctx.putImageData(imageData, 0, 0);
            ctx.strokeStyle = 'rgba(200, 200, 255, 0.1)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 512; i += 128) {
                ctx.beginPath();
                ctx.moveTo(i, 0); ctx.lineTo(i, 512); ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i); ctx.lineTo(512, i); ctx.stroke();
            }
            metallicPatternFloorTexture = new THREE.CanvasTexture(canvas);
            metallicPatternFloorTexture.wrapS = THREE.RepeatWrapping;
            metallicPatternFloorTexture.wrapT = THREE.RepeatWrapping;

            canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            ctx = canvas.getContext('2d');
            ctx.fillStyle = '#888'; ctx.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 60; i++) {
                const x = Math.random() * 256; const y = Math.random() * 256;
                const rX = Math.random() * 20 + 15; const rY = Math.random() * 20 + 15;
                const color = Math.floor(Math.random() * 40) + 90;
                ctx.fillStyle = `rgb(${color},${color},${color})`;
                ctx.beginPath(); ctx.ellipse(x, y, rX, rY, Math.random() * Math.PI, 0, 2 * Math.PI); ctx.fill();
            }
            shuttleRunStoneTexture = new THREE.CanvasTexture(canvas);
            shuttleRunStoneTexture.wrapS = THREE.RepeatWrapping;
            shuttleRunStoneTexture.wrapT = THREE.RepeatWrapping;

            canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            ctx = canvas.getContext('2d');
            ctx.fillStyle = '#4a4a52'; ctx.fillRect(0, 0, 256, 256);
            ctx.strokeStyle = '#686870'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(128, 0); ctx.lineTo(128, 256); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, 128); ctx.lineTo(256, 128); ctx.stroke();
            ctx.fillStyle = '#787880';
            for (let i = 0; i < 4; i++) {
                const cornerX = (i % 2) * 128; const cornerY = Math.floor(i / 2) * 128;
                ctx.beginPath(); ctx.arc(cornerX + 8, cornerY + 8, 3, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(cornerX + 120, cornerY + 8, 3, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(cornerX + 8, cornerY + 120, 3, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(cornerX + 120, cornerY + 120, 3, 0, Math.PI * 2); ctx.fill();
            }
            shuttleRunMetalTexture = new THREE.CanvasTexture(canvas);
            shuttleRunMetalTexture.wrapS = THREE.RepeatWrapping;
            shuttleRunMetalTexture.wrapT = THREE.RepeatWrapping;
            
            shuttleRunFloorTexture = createClassicalPatternTexture();
            missionCorridorFloorTexture = createSimpleGridTexture();

            mazeWallMaterial = new THREE.MeshStandardMaterial({
                color: 0xF5F5DC,
                metalness: 0.7,
                roughness: 0.4
            });

            shuttleRunWallMaterials = [
                new THREE.MeshStandardMaterial({ map: shuttleRunStoneTexture, roughness: 0.8, metalness: 0.1 }),
                new THREE.MeshStandardMaterial({ map: shuttleRunMetalTexture, roughness: 0.8, metalness: 0.6 })
            ];
        }

        function createClassicalPatternTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#BBBBBB';
            ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle = 'rgba(120, 120, 120, 0.5)';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const x = i * 128 + 64;
                    const y = j * 128 + 64;
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(Math.PI / 4 * (i+j));
                    ctx.beginPath();
                    ctx.moveTo(0, -40);
                    ctx.quadraticCurveTo(20, -20, 0, 0);
                    ctx.quadraticCurveTo(-20, -20, 0, -40);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 40);
                    ctx.quadraticCurveTo(20, 20, 0, 0);
                    ctx.quadraticCurveTo(-20, 20, 0, 40);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-40, 0);
                    ctx.quadraticCurveTo(-20, 20, 0, 0);
                    ctx.quadraticCurveTo(-20, -20, -40, 0);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(40, 0);
                    ctx.quadraticCurveTo(20, 20, 0, 0);
                    ctx.quadraticCurveTo(20, -20, 40, 0);
                    ctx.stroke();
                    ctx.restore();
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createSimpleGridTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#3d3d4d';
            ctx.fillRect(0, 0, 256, 256);
            ctx.strokeStyle = 'rgba(150, 150, 200, 0.2)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 256; i += 32) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 256);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(256, i);
                ctx.stroke();
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createWall(x, y, z, width, height, depth, color = 0xaaaaaa) { const g = new THREE.BoxGeometry(width, height, depth); const m = new THREE.MeshStandardMaterial({ color: color }); const w = new THREE.Mesh(g, m); w.position.set(x, y, z); w.receiveShadow = true; w.castShadow = true; scene.add(w); stageObjects.push(w); collidables.push(w); return w; }
        
        function createFloor(width, depth, material) {
            const g = new THREE.PlaneGeometry(width, depth);
            const m = material || new THREE.MeshStandardMaterial({ color: 0x80c080, side: THREE.DoubleSide });
            const f = new THREE.Mesh(g, m);
            f.rotation.x = -Math.PI / 2;
            f.receiveShadow = true;
            scene.add(f);
            stageObjects.push(f);
        }

        function createFinishFlag(x, y, z) { const g = new THREE.Group(); const pg = new THREE.CylinderGeometry(0.1, 0.1, 4, 8); const pm = new THREE.MeshStandardMaterial({ color: 0x666666 }); const p = new THREE.Mesh(pg, pm); p.position.y = 2; g.add(p); const fg = new THREE.PlaneGeometry(1.5, 1); const fm = new THREE.MeshStandardMaterial({ color: 0xff0000, side: THREE.DoubleSide, emissive: 0x550000 }); const f = new THREE.Mesh(fg, fm); f.position.set(0.75, 3.5, 0); g.add(f); g.position.set(x, y, z); g.name = "finish_flag"; scene.add(g); stageObjects.push(g); return g; }
        
        function createHeartBalloon(x, y, z) {
            const balloonGroup = new THREE.Group();
            const heartShape = new THREE.Shape();
            const s = 0.8;
            heartShape.moveTo(0, 0.2 * s);
            heartShape.absarc( -0.4*s, 0.6*s, 0.4*s, Math.PI * 1.5, Math.PI * 0.5, true );
            heartShape.absarc( 0.4*s, 0.6*s, 0.4*s, Math.PI * 0.5, Math.PI * 1.5, true );

            const extrudeSettings = { steps: 2, depth: 0.4, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelOffset: 0, bevelSegments: 8 };
            const geometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
            const material = new THREE.MeshStandardMaterial({ color: 0xff004f, emissive: 0x880011, metalness: 0.4, roughness: 0.5 });
            const balloon = new THREE.Mesh(geometry, material);
            balloon.castShadow = true;
            balloonGroup.add(balloon);
            
            const stringGeo = new THREE.CylinderGeometry(0.02, 0.02, 3, 8);
            const stringMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee });
            const string = new THREE.Mesh(stringGeo, stringMat);
            string.position.y = -1.5;
            balloonGroup.add(string);

            balloonGroup.position.set(x, y + 4.5, z);
            
            balloonGroup.userData.animation = (time) => {
                balloonGroup.position.y = y + 4.5 + Math.sin(time * 1.5) * 0.5;
                balloonGroup.rotation.y = time * 0.3;
            };

            scene.add(balloonGroup);
            stageObjects.push(balloonGroup);
            animatedObjects.push(balloonGroup);
            return balloonGroup;
        }

        function createCapsule(r, h, c) { const g = new THREE.Group(); const m = new THREE.MeshStandardMaterial({ color: c }); const ch = h - (r * 2); const cg = new THREE.CylinderGeometry(r, r, ch, 32); const cyl = new THREE.Mesh(cg, m); cyl.castShadow = true; cyl.receiveShadow = true; g.add(cyl); const sg = new THREE.SphereGeometry(r, 32, 16); const ts = new THREE.Mesh(sg, m); ts.position.y = ch / 2; ts.castShadow = true; ts.receiveShadow = true; g.add(ts); const bs = new THREE.Mesh(sg, m); bs.position.y = -ch / 2; bs.castShadow = true; bs.receiveShadow = true; g.add(bs); g.velocity = new THREE.Vector3(); return g; }
        function createCircularTarget() { const g = new THREE.Group(); g.name = "warmup_target"; const rings = [{ c: 0xffffff, r: 1.5 }, { c: 0xffffff, r: 1.3 }, { c: 0x000000, r: 1.1 }, { c: 0x000000, r: 0.9 }, { c: 0x87CEEB, r: 0.7 }, { c: 0x87CEEB, r: 0.5 }, { c: 0xFF4500, r: 0.4 }, { c: 0xFF4500, r: 0.3 }, { c: 0xFFD700, r: 0.2 }, { c: 0xFFD700, r: 0.1 }]; for (let i = 0; i < rings.length; i++) { const ring = rings[i]; let geo; if (i === rings.length - 1) { geo = new THREE.CircleGeometry(ring.r, 32); } else { geo = new THREE.RingGeometry(rings[i+1].r, ring.r, 32); } const mat = new THREE.MeshStandardMaterial({ color: ring.c, side: THREE.DoubleSide, emissive: 0x000000 }); const mesh = new THREE.Mesh(geo, mat); mesh.position.z = i * 0.001; mesh.userData.isTargetRing = true; g.add(mesh); stageObjects.push(mesh); collidables.push(mesh); } const sg = new THREE.BoxGeometry(0.1, 1.5, 0.1); const sm = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); const s = new THREE.Mesh(sg, sm); s.position.y = -0.75; s.position.z = -0.1; g.add(s); g.position.set(0, 2, -12); scene.add(g); stageObjects.push(g); animatedObjects.push(g); collidables.push(g);}
        function createLandmark(x, z, num) { const lg = new THREE.CylinderGeometry(1, 1, 0.5, 32); const lm = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xccaa00, transparent: true, opacity: 0.8 }); const l = new THREE.Mesh(lg, lm); l.position.set(x, 0.25, z); l.userData = { isLandmark: true, number: num, isFound: false }; scene.add(l); stageObjects.push(l); landmarks.push(l); const loader = new THREE.FontLoader(); loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', (font) => { const tg = new THREE.TextGeometry(num.toString(), { font: font, size: 0.8, height: 0.1 }); tg.computeBoundingBox(); const tm = new THREE.MeshBasicMaterial({ color: 0x000000 }); const t = new THREE.Mesh(tg, tm); t.position.x = -0.5 * (tg.boundingBox.max.x - tg.boundingBox.min.x); t.position.y = 0.3; t.rotation.x = -Math.PI / 2; l.add(t); }); return l; }
        function createInstructionText(text, font, position, color = 0xffffff) { const textLines = text.split('\n'); const textGroup = new THREE.Group(); const textMat = new THREE.MeshBasicMaterial({ color: color }); textLines.forEach((line, index) => { const textGeo = new THREE.TextGeometry(line, { font: font, size: 0.3, height: 0.01 }); textGeo.computeBoundingBox(); const textMesh = new THREE.Mesh(textGeo, textMat); textMesh.position.x = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x); textMesh.position.y = -index * 0.4; textGroup.add(textMesh); }); textGroup.position.copy(position); textGroup.rotation.x = -Math.PI / 2; scene.add(textGroup); stageObjects.push(textGroup); return textGroup; }
        function createPracticeAreaLayout(withObstacles = true) { createFloor(30, 30); createWall(0, 2.5, -15, 30, 5, 0.2); createWall(0, 2.5, 15, 30, 5, 0.2); createWall(-15, 2.5, 0, 0.2, 5, 30); createWall(15, 2.5, 0, 0.2, 5, 30); if (withObstacles) { const oW = 30, oH = 1.2, oD = 0.2; for (let i = 0; i < 5; i++) { createWall(0, oH / 2, -2 - (i * 2), oW, oH, oD, 0xcc5555); } } }
        
        function createCourtyardLamp(x, y, z) {
            const lampGroup = new THREE.Group();
            const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9, roughness: 0.5 });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = 0.75;
            lampGroup.add(pole);
            const headGeo = new THREE.SphereGeometry(0.2, 16, 8);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffffdd, emissive: 0xffffaa, emissiveIntensity: 1 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.5;
            lampGroup.add(head);
            const pointLight = new THREE.PointLight(0xfff0d1, 2, 8);
            pointLight.position.y = 1.5;
            pointLight.castShadow = true; 
            lampGroup.add(pointLight);
            lampGroup.position.set(x, y, z);
            lampGroup.castShadow = true;
            scene.add(lampGroup);
            stageObjects.push(lampGroup);
        }
        
        function createStreetLight(x, y, z) {
            const lightGroup = new THREE.Group();
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x4B4B4B, metalness: 0.9, roughness: 0.5 });
            const poleGeo = new THREE.CylinderGeometry(0.1, 0.15, 3.5, 8);
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = 1.75;
            pole.castShadow = true;
            lightGroup.add(pole);
            const armGeo = new THREE.BoxGeometry(0.15, 0.15, 1);
            const arm = new THREE.Mesh(armGeo, poleMat);
            arm.position.set(0, 3.3, 0.5);
            lightGroup.add(arm);
            const lampHeadMat = new THREE.MeshStandardMaterial({ color: 0xffffdd, emissive: 0xffffaa, emissiveIntensity: 1.5 });
            const lampHeadGeo = new THREE.BoxGeometry(0.3, 0.2, 0.3);
            const lampHead = new THREE.Mesh(lampHeadGeo, lampHeadMat);
            lampHead.position.set(0, 3.1, 0.85);
            lightGroup.add(lampHead);
            const pointLight = new THREE.PointLight(0xfff0d1, 0.01, 15);
            pointLight.position.set(0, 3.0, 0.85);
            pointLight.castShadow = false;
            lightGroup.add(pointLight);
            lightGroup.position.set(x, y, z);
            scene.add(lightGroup);
            stageObjects.push(lightGroup);
            return lightGroup;
        }

        function setupStage0_Warmup() { 
            camera.position.set(0, playerHeight, 10); 
            camera.quaternion.set(0, 0, 0, 1); 
            euler.set(0, 0, 0, 'YXZ'); 
            createPracticeAreaLayout(); 
            createCircularTarget(); 
            const loader = new THREE.FontLoader(); 
            loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function (font) { 
                const textMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE65A, metalness: 0.8, roughness: 0.4, emissive: 0xFFB300, emissiveIntensity: 0.4 }); 
                const textGeo = new THREE.TextGeometry('Welcome', { font: font, size: 1.5, height: 0.3, curveSegments: 12, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.03, bevelOffset: 0, bevelSegments: 5 }); 
                textGeo.computeBoundingBox(); 
                const textMesh = new THREE.Mesh(textGeo, textMaterial); 
                textMesh.position.set(-0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x), 4, 0);
                textMesh.castShadow = true; 
                textMesh.name = "welcome_text";
                animatedObjects.push({ userData: { animation: (time) => { textMesh.position.y = 4 + Math.sin(time * 1.5) * 0.2; textMesh.rotation.y = Math.sin(time * 0.5) * 0.2; } } });
                scene.add(textMesh); 
                stageObjects.push(textMesh); 

                createWasdTrainingArea(font);
                
                const skillGroup = new THREE.Group();
                skillGroup.name = "skill_device";
                const pinkColor = 0xff88cc;
                const jumpObstacle = createWall(10, 0.5, 5, 2, 1, 2, 0xff8c00);
                const jumpText = createInstructionText(' Jump\n(Space + W/A/S/D)', font, new THREE.Vector3(10, 0.01, 7), pinkColor);
                
                const crouchObstacleTop = createWall(10, 1.5, 0, 2.2, 0.2, 0.2, 0x708090);
                const crouchObstacleLeft = createWall(8.9, 0.75, 0, 0.2, 1.5, 0.2, 0x708090);
                const crouchObstacleRight = createWall(11.1, 0.75, 0, 0.2, 1.5, 0.2, 0x708090);
                const crouchText = createInstructionText(' Crouch\n(Shift + W/A/S/D)', font, new THREE.Vector3(10, 0.01, 2), pinkColor);
                
                skillGroup.add(jumpObstacle, jumpText, crouchObstacleTop, crouchObstacleLeft, crouchObstacleRight, crouchText);
                scene.add(skillGroup);
                stageObjects.push(skillGroup);
                collidables.push(jumpObstacle, crouchObstacleTop, crouchObstacleLeft, crouchObstacleRight);
            }); 
            if (gameMode === 'campaign') {
                startWarmupCountdown();
            }
        }

        function startWarmupCountdown() {
            if (warmupCountdownInterval) clearInterval(warmupCountdownInterval);
            
            let countdown = 30;
            warmupTimerDisplayElement.style.display = 'block';
            warmupTimerDisplayElement.textContent = `第一关训练倒计时: ${countdown}s`;

            warmupCountdownInterval = setInterval(() => {
                countdown--;
                warmupTimerDisplayElement.textContent = `第一关训练倒计时: ${countdown}s`;

                if (countdown <= 0) {
                    clearInterval(warmupCountdownInterval);
                    warmupCountdownInterval = null;
                    warmupTimerDisplayElement.style.display = 'none';
                    if (document.pointerLockElement) document.exitPointerLock();
                    warmupConfirmOverlay.style.display = 'flex';
                }
            }, 1000);
        }

        function createWasdTrainingArea(font) {
            const wasdGroup = new THREE.Group();
            wasdGroup.name = "wasd_device";
            const areaCenter = new THREE.Vector3(-10, 0.01, 5);
            const keySize = 2;
            const keySpacing = 2.5;
            const inactiveMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.5, roughness: 0.8 });
            const activeMat = new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xFFFF00, emissiveIntensity: 0.8 });
            const textMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const centerGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 32);
            const centerInactiveMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 });
            const centerActiveMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.8 });
            const centerButtonMesh = new THREE.Mesh(centerGeo, centerInactiveMat.clone());
            centerButtonMesh.position.set(areaCenter.x, 0.1, areaCenter.z);
            centerButtonMesh.castShadow = true;
            wasdGroup.add(centerButtonMesh);
            wasdCenterButton = {
                mesh: centerButtonMesh,
                boundingBox: new THREE.Box3().setFromObject(centerButtonMesh),
                inactiveMaterial: centerInactiveMat,
                activeMaterial: centerActiveMat
            };
            const createKey = (letter, position) => {
                const keyGroup = new THREE.Group();
                keyGroup.position.copy(position);
                const planeGeo = new THREE.PlaneGeometry(keySize, keySize);
                const plane = new THREE.Mesh(planeGeo, inactiveMat.clone());
                plane.rotation.x = -Math.PI / 2;
                plane.receiveShadow = true;
                keyGroup.add(plane);
                collidables.push(plane);
                const textGeo = new THREE.TextGeometry(letter, { font: font, size: 1, height: 0.1 });
                textGeo.computeBoundingBox();
                const text = new THREE.Mesh(textGeo, textMat);
                text.position.set(-0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x), 0.05, 0.5);
                text.rotation.x = -Math.PI / 2;
                keyGroup.add(text);
                wasdGroup.add(keyGroup);
                keyGroup.updateMatrixWorld(true);
                wasdTrainingKeys.push({
                    letter: letter,
                    mesh: plane,
                    boundingBox: new THREE.Box3().setFromObject(keyGroup),
                    inactiveMaterial: plane.material,
                    activeMaterial: activeMat
                });
            };
            createKey('W', new THREE.Vector3(areaCenter.x, areaCenter.y, areaCenter.z - keySpacing));
            createKey('A', new THREE.Vector3(areaCenter.x - keySpacing, areaCenter.y, areaCenter.z));
            createKey('S', new THREE.Vector3(areaCenter.x, areaCenter.y, areaCenter.z + keySpacing));
            createKey('D', new THREE.Vector3(areaCenter.x + keySpacing, areaCenter.y, areaCenter.z));
            scene.add(wasdGroup);
            stageObjects.push(wasdGroup);
        }

        function startNextTrainingCommand() {
            const keys = ['W', 'A', 'S', 'D'];
            currentTrainingKey = keys[Math.floor(Math.random() * keys.length)];
            isWaitingForNextCommand = false;
            let direction_zh, direction_en;
            switch(currentTrainingKey) {
                case 'W': direction_zh = '前'; direction_en = 'Forward'; break;
                case 'A': direction_zh = '左'; direction_en = 'Left'; break;
                case 'S': direction_zh = '后'; direction_en = 'Backward'; break;
                case 'D': direction_zh = '右'; direction_en = 'Right'; break;
            }
            trainingCommandElement.innerHTML = `请移动到：${direction_zh} (${currentTrainingKey})<br><span style="font-size:16px; color: #ccc;">Please move to: ${direction_en} (${currentTrainingKey})</span><br><br><span style="font-size:12px; color: #aaa;">(点击鼠标左键可随时取消 / Left-click to cancel anytime)</span>`;
            trainingCommandElement.style.display = 'block';
        }

        function updateWasdTraining() {
            if (!wasdCenterButton) return;
            const playerPos = camera.position;

            if (!wasdTrainingActivated) {
                const box = wasdCenterButton.boundingBox;
                if (playerPos.x >= box.min.x && playerPos.x <= box.max.x &&
                    playerPos.z >= box.min.z && playerPos.z <= box.max.z) {
                    wasdTrainingActivated = true;
                    wasdCenterButton.mesh.material = wasdCenterButton.activeMaterial;
                    create3DFirework(wasdCenterButton.mesh.position);
                    if (document.pointerLockElement) document.exitPointerLock();
                    trainingChoiceOverlay.style.display = 'flex';
                }
                return;
            }

            if (!wasdTrainingMode) return;

            if (wasdTrainingMode === 'special') {
                if (!isWaitingForNextCommand) {
                    const correctKey = wasdTrainingKeys.find(k => k.letter === currentTrainingKey);
                    if (correctKey) {
                        const box = correctKey.boundingBox;
                        const isPlayerOnCorrectKey = playerPos.x >= box.min.x && playerPos.x <= box.max.x &&
                                                     playerPos.z >= box.min.z && playerPos.z <= box.max.z;
                        if (isPlayerOnCorrectKey) {
                            isWaitingForNextCommand = true;
                            trainingCommandElement.innerHTML = `太棒了！请返回中心红色按钮<br><span style="font-size:16px; color: #ccc;">Great! Please return to the red button</span><br><br><span style="font-size:12px; color: #aaa;">(点击鼠标左键可随时取消 / Left-click to cancel anytime)</span>`;
                        }
                    }
                } 
                else {
                    const box = wasdCenterButton.boundingBox;
                    const isPlayerOnCenter = playerPos.x >= box.min.x && playerPos.x <= box.max.x &&
                                             playerPos.z >= box.min.z && playerPos.z <= box.max.z;
                    if (isPlayerOnCenter) {
                        startNextTrainingCommand();
                    }
                }
            }

            wasdTrainingKeys.forEach(key => {
                const box = key.boundingBox;
                const isPlayerOnKey = playerPos.x >= box.min.x && playerPos.x <= box.max.x &&
                                      playerPos.z >= box.min.z && playerPos.z <= box.max.z;
                
                let shouldBeLit = false;
                if (isPlayerOnKey) {
                    if (wasdTrainingMode === 'free') {
                        shouldBeLit = true;
                    } else if (wasdTrainingMode === 'special') {
                        if (key.letter === currentTrainingKey) {
                            shouldBeLit = true;
                        }
                    }
                }
                key.mesh.material = shouldBeLit ? key.activeMaterial : key.inactiveMaterial;
            });
            
            if (wasdTrainingMode === 'special' && isWaitingForNextCommand) {
                 wasdCenterButton.mesh.material = wasdCenterButton.activeMaterial;
            } else {
                 wasdCenterButton.mesh.material = wasdCenterButton.inactiveMaterial;
            }
        }

        function setupStage1_Look() { camera.position.set(0, playerHeight, 5); camera.quaternion.set(0, 0, 0, 1); euler.set(0, 0, 0, 'YXZ'); createFloor(20, 20); createWall(0, 2.5, -10, 20, 5, 0.2); createWall(0, 2.5, 10, 20, 5, 0.2); createWall(-10, 2.5, 0, 0.2, 5, 20); createWall(10, 2.5, 0, 0.2, 5, 20); const targetPositions = [new THREE.Vector3(0, 1.5, -8), new THREE.Vector3(8, 2, 0), new THREE.Vector3(-7, 1, 3), new THREE.Vector3(0, 3, 8)]; targetPositions.forEach(pos => { const targetGeo = new THREE.SphereGeometry(0.5, 32, 32); const targetMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 }); const target = new THREE.Mesh(targetGeo, targetMat); target.position.copy(pos); target.userData.isTarget = true; scene.add(target); stageObjects.push(target); stage1Targets.push(target); }); updateInstructions(); }
        
        function setupShuttleRunLevel(isMoving, speed) {
            camera.position.set(0, playerHeight, 0);
            camera.quaternion.set(0, 0, 0, 1);
            euler.set(0, 0, 0, 'YXZ');
            
            scene.background.set(0x4a4a6a);
            scene.fog = new THREE.Fog(0x4a4a6a, 0, 100);
            
            const mapSize = 80;
            
            // MODIFICATION: Changed floor texture to missionCorridorFloorTexture
            missionCorridorFloorTexture.repeat.set(mapSize / 4, mapSize / 4);
            missionCorridorFloorTexture.needsUpdate = true;
            const floorMaterial = new THREE.MeshStandardMaterial({
                map: missionCorridorFloorTexture,
                metalness: 0,
                roughness: 0.8
            });
            createFloor(mapSize, mapSize, floorMaterial);

            createPillarsForShuttleRun(20, mapSize / 2 - 5);
            createShuttleRunWalls(mapSize); 

            shuttleRunMaterials = {
                green: new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x005500 }),
                red: new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x880000 }),
                yellow: new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0x888800 }),
            };

            const targets = [];
            const spawnRadius = mapSize / 2 - 10; 
            for (let i = 0; i < 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 5 + Math.random() * (spawnRadius - 5);
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                const buttonGeo = new THREE.CylinderGeometry(1, 1, 0.4, 32);
                const button = new THREE.Mesh(buttonGeo, shuttleRunMaterials.green.clone());
                button.position.set(x, 0.2, z);
                button.castShadow = true;
                if (isMoving) {
                    button.velocity = new THREE.Vector3((Math.random() - 0.5), 0, (Math.random() - 0.5)).normalize().multiplyScalar(speed);
                    button.userData.trailTimer = 0; 
                }
                scene.add(button);
                stageObjects.push(button);
                targets.push(button);
            }

            shuttleRunState = {
                targets: targets,
                activeTarget: null,
                completedCount: 0,
                availableIndices: [...Array(10).keys()],
                spawnRadius: spawnRadius
            };
            
            genericCounterElement.style.display = 'block';
            updateGenericCounter(`已完成: 0 / 10`);
            
            activateNextShuttleTarget();
        }

        function createShuttleRunWalls(mapSize) {
            const wallHeight = 20;

            shuttleRunWallMaterials.forEach(mat => {
                if (mat.map) {
                    mat.map.repeat.set(mapSize / 10, wallHeight / 10);
                    mat.map.needsUpdate = true;
                }
            });

            const wallGeo = new THREE.PlaneGeometry(mapSize, wallHeight);
            
            const wall1 = new THREE.Mesh(wallGeo, shuttleRunWallMaterials[0]); // Stone
            wall1.position.set(0, wallHeight / 2, -mapSize / 2);
            scene.add(wall1);
            collidables.push(wall1);

            const wall2 = new THREE.Mesh(wallGeo, shuttleRunWallMaterials[0]); // Stone
            wall2.position.set(0, wallHeight / 2, mapSize / 2);
            wall2.rotation.y = Math.PI;
            scene.add(wall2);
            collidables.push(wall2);
            
            const wall3 = new THREE.Mesh(wallGeo, shuttleRunWallMaterials[1]); // Metal
            wall3.position.set(mapSize / 2, wallHeight / 2, 0);
            wall3.rotation.y = -Math.PI / 2;
            scene.add(wall3);
            collidables.push(wall3);

            const wall4 = new THREE.Mesh(wallGeo, shuttleRunWallMaterials[1]); // Metal
            wall4.position.set(-mapSize / 2, wallHeight / 2, 0);
            wall4.rotation.y = Math.PI / 2;
            scene.add(wall4);
            collidables.push(wall4);
        }

        function createPillarsForShuttleRun(count, radius) {
            for(let i = 0; i < count; i++) {
                const pillarGroup = new THREE.Group();

                const baseGeo = new THREE.CylinderGeometry(0.8, 1, 0.5, 16);
                const baseMat = new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.8, roughness: 0.3 });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = 0.25;
                pillarGroup.add(base);

                const bodyGeo = new THREE.CylinderGeometry(0.5, 0.7, 8, 16);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0x777788, metalness: 0.6, roughness: 0.5 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 4.5; 
                pillarGroup.add(body);

                const topGeo = new THREE.IcosahedronGeometry(0.6, 0);
                const topMat = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff, 
                    emissive: 0x00ffff, 
                    emissiveIntensity: 1.5,
                    metalness: 0.2,
                    roughness: 0.1
                });
                const top = new THREE.Mesh(topGeo, topMat);
                top.position.y = 9; 
                pillarGroup.add(top);
                
                const ringGeo = new THREE.TorusGeometry(0.8, 0.05, 8, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 1; 
                pillarGroup.add(ring);
                
                ring.userData.animation = (time) => {
                    ring.position.y = 1 + (Math.sin(time * 2 + i) + 1) / 2 * 7; 
                    ring.material.opacity = 0.5 + (Math.sin(time * 2 + i) + 1) / 4;
                };
                animatedObjects.push(ring);

                const angle = Math.random() * Math.PI * 2;
                const r = 10 + Math.random() * (radius - 10);
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                pillarGroup.position.set(x, 0, z);

                pillarGroup.castShadow = true;
                pillarGroup.receiveShadow = true;
                
                scene.add(pillarGroup);
                stageObjects.push(pillarGroup);
                collidables.push(body); 
            }
        }

        function setupStage3_ShuttleRun_Static() { setupShuttleRunLevel(false, 0); }
        function setupStage4_ShuttleRun_Moving() { setupShuttleRunLevel(true, 2.5); }
        function setupStage5_ShuttleRun_HighSpeed() { setupShuttleRunLevel(true, 5.0); }

        function updateShuttleRunTargets(deltaTime) {
            if (!shuttleRunState.targets) return;
            const radius = shuttleRunState.spawnRadius;
            shuttleRunState.targets.forEach(target => {
                if (target.velocity) {
                    target.position.add(target.velocity.clone().multiplyScalar(deltaTime));
                    
                    if (target.position.x > radius || target.position.x < -radius) {
                        target.velocity.x *= -1;
                        target.position.x = Math.sign(target.position.x) * radius;
                    }
                    if (target.position.z > radius || target.position.z < -radius) {
                        target.velocity.z *= -1;
                        target.position.z = Math.sign(target.position.z) * radius;
                    }

                    if (target === shuttleRunState.activeTarget) {
                        target.userData.trailTimer += deltaTime;
                        if (target.userData.trailTimer > 0.05) {
                            target.userData.trailTimer = 0;
                            createTrailParticle(target.position);
                        }
                    }
                }
            });
        }

        function activateNextShuttleTarget() {
            if (shuttleRunState.availableIndices.length === 0) {
                shuttleRunState.activeTarget = null;
                return;
            }
            const randomIndex = Math.floor(Math.random() * shuttleRunState.availableIndices.length);
            const targetIndex = shuttleRunState.availableIndices.splice(randomIndex, 1)[0];
            
            const newTarget = shuttleRunState.targets[targetIndex];
            newTarget.material = shuttleRunMaterials.red;
            shuttleRunState.activeTarget = newTarget;
        }

        function setupStage6_MissionCorridor() {
            camera.position.set(0, playerHeight, 48);
            camera.quaternion.set(0, 0, 0, 1);
            euler.set(0, 0, 0, 'YXZ'); 
            
            const corridorLength = 100;
            const corridorWidth = 30;
            
            missionCorridorFloorTexture.repeat.set(corridorWidth / 4, corridorLength / 4);
            missionCorridorFloorTexture.needsUpdate = true;
            const floorMaterial = new THREE.MeshStandardMaterial({
                map: missionCorridorFloorTexture,
            });
            createFloor(corridorWidth, corridorLength, floorMaterial);
            createFinishFlag(0, 0, -49);

            const allTargets = [];
            activatedCorridorTargets.clear();
            const sphereGeo = new THREE.SphereGeometry(0.5, 32, 16);
            
            for(let i = 0; i < 8; i++) {
                const sphereMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 });
                const sphere = new THREE.Mesh(sphereGeo, sphereMat);
                const randomHeight = playerHeight + (Math.random() * playerHeight);
                sphere.position.set(-corridorWidth / 2.2, randomHeight, 40 - i * 10);
                sphere.castShadow = true;
                sphere.visible = false;
                allTargets.push(sphere);
            }
            for(let i = 0; i < 8; i++) {
                const sphereMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 });
                const sphere = new THREE.Mesh(sphereGeo, sphereMat);
                const randomHeight = playerHeight + (Math.random() * playerHeight);
                sphere.position.set(corridorWidth / 2.2, randomHeight, -5 - i * 5);
                sphere.castShadow = true;
                sphere.visible = false;
                allTargets.push(sphere);
            }
            
            corridorState = {
                allTargets: allTargets,
                batchSize: 5,
                currentBatchIndex: 0,
                activatedInBatch: 0,
                spheresInCurrentBatch: 0
            };

            showNextCorridorBatch();
            
            genericCounterElement.style.display = 'block';
            updateGenericCounter(`已激活: 0 / ${corridorState.allTargets.length}`);
        }
        
        function showNextCorridorBatch() {
            const { allTargets, batchSize, currentBatchIndex } = corridorState;
            const startIndex = currentBatchIndex * batchSize;
            if (startIndex >= allTargets.length) return; 

            const endIndex = Math.min(startIndex + batchSize, allTargets.length);
            corridorState.spheresInCurrentBatch = 0;

            for (let i = startIndex; i < endIndex; i++) {
                const sphere = allTargets[i];
                scene.add(sphere);
                stageObjects.push(sphere);
                corridorTargets.push(sphere);
                sphere.visible = true;
                corridorState.spheresInCurrentBatch++;
            }
            
            corridorState.currentBatchIndex++;
            corridorState.activatedInBatch = 0;
        }

        function handleCorridorAiming() {
            raycaster.setFromCamera(centerScreen, camera);
            const intersects = raycaster.intersectObjects(corridorTargets);
            if (intersects.length > 0) {
                const aimedObject = intersects[0].object;
                if (camera.position.distanceTo(aimedObject.position) > 15) return;

                if (!activatedCorridorTargets.has(aimedObject)) {
                    aimedObject.material.color.setHex(0x00ff00);
                    aimedObject.material.emissive.setHex(0x008800);
                    activatedCorridorTargets.add(aimedObject);
                    corridorState.activatedInBatch++;
                    
                    updateGenericCounter(`已激活: ${activatedCorridorTargets.size} / ${corridorState.allTargets.length}`);
                    updateInstructions();

                    if (corridorState.activatedInBatch >= corridorState.spheresInCurrentBatch) {
                        showNextCorridorBatch();
                    }
                }
            }
        }

        function setupStage7_Move() {
            camera.position.set(0, playerHeight, 18);
            camera.quaternion.set(0, 0, 0, 1);
            euler.set(0, 0, 0, 'YXZ');
            
            stonePathTexture.repeat.set(5, 5);
            stonePathTexture.needsUpdate = true;
            const floorMaterial = new THREE.MeshStandardMaterial({
                map: stonePathTexture,
                roughness: 0.8
            });
            createFloor(40, 40, floorMaterial);

            createWall(0, 2.5, 20, 40, 5, 0.2);
            createWall(0, 2.5, -20, 40, 5, 0.2);
            createWall(20, 2.5, 0, 0.2, 5, 40);
            createWall(-20, 2.5, 0, 0.2, 5, 40);
            createWall(0, 2.5, 10, 30, 5, 0.2);
            createWall(10, 2.5, 0, 20, 5, 0.2);
            createWall(-15, 2.5, 5, 0.2, 5, 10);
            createWall(0, 2.5, -10, 30, 5, 0.2);
            createWall(-5, 2.5, -5, 0.2, 5, 10);
            
            const finishFlag = createFinishFlag(12, 0, -18);
            
            scene.userData.mazeCols = 40;
            scene.userData.mazeRows = 40;
            scene.userData.cellSize = 1;
            scene.userData.endPos = finishFlag.position.clone();
            scene.userData.startPos = camera.position.clone();
            scene.userData.routePath = [
                new THREE.Vector3(0, 0, 18), new THREE.Vector3(0, 0, 12),
                new THREE.Vector3(-15, 0, 12), new THREE.Vector3(-15, 0, -15),
                new THREE.Vector3(12, 0, -15), new THREE.Vector3(12, 0, -18)
            ];
            scene.userData.walls = [
                {x: 0, z: 10, w: 30, d: 0.2}, {x: 10, z: 0, w: 20, d: 0.2},
                {x: -15, z: 5, w: 0.2, d: 10}, {x: 0, z: -10, w: 30, d: 0.2},
                {x: -5, z: -5, w: 0.2, d: 10}
            ];
        }
        function setupStage8_Jump() { camera.position.set(0, playerHeight, 18); camera.quaternion.set(0, 0, 0, 1); euler.set(0, 0, 0, 'YXZ'); const pathWidth = 4; createFloor(pathWidth, 40); createWall(-pathWidth/2, 2.5, 0, 0.2, 5, 40); createWall(pathWidth/2, 2.5, 0, 0.2, 5, 40); createWall(0, 2.5, 20, pathWidth, 5, 0.2); const obstacleHeight = 1.5; const obstacleY = obstacleHeight / 2; createWall(0, obstacleY, 12, pathWidth, obstacleHeight, 2, 0xff8c00); createWall(0, obstacleY, 6, pathWidth, obstacleHeight, 2, 0xff8c00); createWall(0, obstacleY, 0, pathWidth, obstacleHeight, 2, 0xff8c00); createWall(0, obstacleY, -6, pathWidth, obstacleHeight, 2, 0xff8c00); createWall(0, obstacleY, -12, pathWidth, obstacleHeight, 2, 0xff8c00); createFinishFlag(0, 0, -19); }
        function setupStage9_Skills() { camera.position.set(0, playerHeight, 23); camera.quaternion.set(0, 0, 0, 1); euler.set(0, 0, 0, 'YXZ'); const pathWidth = 4; const pathLength = 50; createFloor(pathWidth, pathLength); createWall(-pathWidth/2, 2.5, 0, 0.2, 5, pathLength); createWall(pathWidth/2, 2.5, 0, 0.2, 5, pathLength); createWall(0, 2.5, pathLength/2, pathWidth, 5, 0.2); const jumpHeight = 1.5; const jumpY = jumpHeight / 2; const crouchBarrierHeight = 1.5; const crouchBarrierY = 2.25; createWall(0, jumpY, 20, pathWidth, jumpHeight, 0.5, 0xff8c00); createWall(0, crouchBarrierY, 15, pathWidth, crouchBarrierHeight, 0.5, 0x708090); createWall(0, jumpY, 10, pathWidth, jumpHeight, 0.5, 0xff8c00); createWall(0, jumpY, 5, pathWidth, jumpHeight, 0.5, 0xff8c00); createWall(0, crouchBarrierY, 0, pathWidth, crouchBarrierHeight, 0.5, 0x708090); createWall(0, crouchBarrierY, -5, pathWidth, crouchBarrierHeight, 0.5, 0x708090); createWall(0, jumpY, -10, pathWidth, jumpHeight, 0.5, 0xff8c00); createWall(0, crouchBarrierY, -15, pathWidth, crouchBarrierHeight, 0.5, 0x708090); createFinishFlag(0, 0, -24); }
        
        function setupTimedMazeLevel(mazeLayout) {
            const cellSize = 5;
            const wallHeight = 4;
            const wallY = wallHeight / 2;
            const mazeRows = mazeLayout.length;
            const mazeCols = mazeLayout[0].length;
            const mapWidth = mazeCols * cellSize;
            const mapLength = mazeRows * cellSize;
            let startPos = new THREE.Vector3();
            let endPos = new THREE.Vector3();
            const offsetX = -mapWidth / 2;
            const offsetZ = -mapLength / 2;
            
            stonePathTexture.repeat.set(mapWidth / 4, mapLength / 4);
            stonePathTexture.needsUpdate = true;
            const floorMaterial = new THREE.MeshStandardMaterial({
                map: stonePathTexture,
                roughness: 0.9,
            });
            createFloor(mapWidth, mapLength, floorMaterial);

            let startCoords = { r: -1, c: -1 };
            let endCoords = { r: -1, c: -1 };
            for (let i = 0; i < mazeRows; i++) {
                for (let j = 0; j < mazeCols; j++) {
                    if (mazeLayout[i][j] === 'S') startCoords = { r: i, c: j };
                    if (mazeLayout[i][j] === 'E') endCoords = { r: i, c: j };
                }
            }

            const wallGeo = new THREE.BoxGeometry(cellSize, wallHeight, cellSize);

            for (let i = 0; i < mazeRows; i++) {
                for (let j = 0; j < mazeCols; j++) {
                    const x = j * cellSize + offsetX + cellSize / 2;
                    const z = i * cellSize + offsetZ + cellSize / 2;
                    const cell = mazeLayout[i][j];

                    if (cell === 1) { 
                        const wall = new THREE.Mesh(wallGeo, mazeWallMaterial);
                        wall.position.set(x, wallY, z);
                        wall.receiveShadow = true;
                        wall.castShadow = true;
                        scene.add(wall);
                        stageObjects.push(wall);
                        collidables.push(wall);
                    } else {
                        const distToStart = Math.sqrt(Math.pow(i - startCoords.r, 2) + Math.pow(j - startCoords.c, 2));
                        const distToEnd = Math.sqrt(Math.pow(i - endCoords.r, 2) + Math.pow(j - endCoords.c, 2));
                        
                        const isWall = (r, c) => (r < 0 || r >= mazeRows || c < 0 || c >= mazeCols || mazeLayout[r][c] === 1);
                        const wallUp = isWall(i - 1, j);
                        const wallDown = isWall(i + 1, j);
                        const wallLeft = isWall(i, j - 1);
                        const wallRight = isWall(i, j + 1);
                        const wallCount = (wallUp ? 1:0) + (wallDown ? 1:0) + (wallLeft ? 1:0) + (wallRight ? 1:0);

                        if ((wallCount === 3 || (wallCount === 2 && !(wallUp && wallDown) && !(wallLeft && wallRight))) && distToStart > 1.5 && distToEnd > 1.5 ) {
                            const lightX = x + (Math.random() - 0.5) * cellSize * 0.2;
                            const lightZ = z + (Math.random() - 0.5) * cellSize * 0.2;
                            createStreetLight(lightX, 0, lightZ);
                        }
                    }

                    switch (cell) {
                        case 'S': startPos.set(x, playerHeight, z); break;
                        case 'E': endPos.set(x, 0, z); createHeartBalloon(x, 0, z); break;
                        case 'J': createWall(x, 0.75, z, cellSize, 1.5, cellSize, 0xff8c00); break;
                        case 'C': createWall(x, 2.25, z, cellSize, 1.5, cellSize, 0x708090); break;
                    }
                }
            }
            camera.position.copy(startPos);
            camera.quaternion.set(0, 0, 0, 1);
            euler.set(0, Math.PI, 0, 'YXZ');
            camera.quaternion.setFromEuler(euler);
            scene.userData.mazeLayout = mazeLayout;
            scene.userData.mazeRows = mazeRows;
            scene.userData.mazeCols = mazeCols;
            scene.userData.cellSize = cellSize;
            scene.userData.endPos = endPos;
        }
        
        function setupChaseMazeLevel(mazeLayout, npcCount) {
            const cellSize = 6;
            const wallHeight = 5;
            const wallY = wallHeight / 2;
            const mazeRows = mazeLayout.length;
            const mazeCols = mazeLayout[0].length;
            const mapWidth = mazeCols * cellSize;
            const mapLength = mazeRows * cellSize;
            let startPos = new THREE.Vector3();
            const offsetX = -mapWidth / 2;
            const offsetZ = -mapLength / 2;
            
            stonePathTexture.repeat.set(mapWidth / 4, mapLength / 4);
            stonePathTexture.needsUpdate = true;
            const floorMaterial = new THREE.MeshStandardMaterial({
                map: stonePathTexture,
                roughness: 0.9
            });
            createFloor(mapWidth, mapLength, floorMaterial);

            let startCoords = { r: -1, c: -1 };
            for (let i = 0; i < mazeRows; i++) {
                for (let j = 0; j < mazeCols; j++) {
                    if (mazeLayout[i][j] === 'S') startCoords = { r: i, c: j };
                }
            }

            const wallGeo = new THREE.BoxGeometry(cellSize, wallHeight, cellSize);

            for (let i = 0; i < mazeRows; i++) {
                for (let j = 0; j < mazeCols; j++) {
                    const x = j * cellSize + offsetX + cellSize / 2;
                    const z = i * cellSize + offsetZ + cellSize / 2;
                    const cell = mazeLayout[i][j];

                    if (cell === 1) {
                        const wall = new THREE.Mesh(wallGeo, mazeWallMaterial);
                        wall.position.set(x, wallY, z);
                        wall.receiveShadow = true;
                        wall.castShadow = true;
                        scene.add(wall);
                        stageObjects.push(wall);
                        collidables.push(wall);
                    } else {
                        const distToStart = Math.sqrt(Math.pow(i - startCoords.r, 2) + Math.pow(j - startCoords.c, 2));
                        
                        const isWall = (r, c) => (r < 0 || r >= mazeRows || c < 0 || c >= mazeCols || mazeLayout[r][c] === 1);
                        const wallUp = isWall(i - 1, j);
                        const wallDown = isWall(i + 1, j);
                        const wallLeft = isWall(i, j - 1);
                        const wallRight = isWall(i, j + 1);
                        const wallCount = (wallUp ? 1:0) + (wallDown ? 1:0) + (wallLeft ? 1:0) + (wallRight ? 1:0);

                        if ((wallCount === 3 || (wallCount === 2 && !(wallUp && wallDown) && !(wallLeft && wallRight))) && distToStart > 1.5) {
                            const lightX = x + (Math.random() - 0.5) * cellSize * 0.2;
                            const lightZ = z + (Math.random() - 0.5) * cellSize * 0.2;
                            createStreetLight(lightX, 0, lightZ);
                        }
                    }

                    switch (cell) {
                        case 'S': startPos.set(x, playerHeight, z); break;
                        case 'N': const npc = createCapsule(0.4, 1.8, 0x0099ff); npc.position.set(x, 0.9, z); scene.add(npc); npcs.push(npc); stageObjects.push(npc); break;
                        case 'J': createWall(x, 0.75, z, cellSize, 1.5, cellSize, 0xff8c00); break;
                        case 'C': createWall(x, 2.25, z, cellSize, 1.5, cellSize, 0x708090); break;
                    }
                }
            }
            camera.position.copy(startPos);
            camera.quaternion.set(0, 0, 0, 1);
            euler.set(0, Math.PI, 0, 'YXZ');
            camera.quaternion.setFromEuler(euler);
            scene.userData.mazeLayout = mazeLayout;
            scene.userData.mazeRows = mazeRows;
            scene.userData.mazeCols = mazeCols;
            scene.userData.cellSize = cellSize;
            scene.userData.totalNpcs = npcCount;
            updateNpcCounter();
            npcCounterElement.style.display = 'block';
        }
        
        function setupLandmarkMazeLevel(mazeLayout) {
            const cellSize = 8;
            const wallHeight = 5;
            const wallY = wallHeight / 2;
            const mazeRows = mazeLayout.length;
            const mazeCols = mazeLayout[0].length;
            const mapWidth = mazeCols * cellSize;
            const mapLength = mazeRows * cellSize;
            let startPos = new THREE.Vector3();
            const offsetX = -mapWidth / 2;
            const offsetZ = -mapLength / 2;
            
            stonePathTexture.repeat.set(mapWidth / 4, mapLength / 4);
            stonePathTexture.needsUpdate = true;
            const floorMaterial = new THREE.MeshStandardMaterial({
                map: stonePathTexture,
                roughness: 0.9
            });
            createFloor(mapWidth, mapLength, floorMaterial);

            let startCoords = { r: -1, c: -1 };
            for (let i = 0; i < mazeRows; i++) {
                for (let j = 0; j < mazeCols; j++) {
                    if (mazeLayout[i][j] === 'S') {
                        startCoords = { r: i, c: j };
                        break; 
                    }
                }
                if (startCoords.r !== -1) break;
            }

            const wallGeo = new THREE.BoxGeometry(cellSize, wallHeight, cellSize);

            let landmarkCounter = 1;
            const minDistFromStart = 3.5;

            for (let i = 0; i < mazeRows; i++) {
                for (let j = 0; j < mazeCols; j++) {
                    const x = j * cellSize + offsetX + cellSize / 2;
                    const z = i * cellSize + offsetZ + cellSize / 2;
                    const cell = mazeLayout[i][j];

                    if (cell === 1) {
                        const wall = new THREE.Mesh(wallGeo, mazeWallMaterial);
                        wall.position.set(x, wallY, z);
                        wall.receiveShadow = true;
                        wall.castShadow = true;
                        scene.add(wall);
                        stageObjects.push(wall);
                        collidables.push(wall);
                    } else {
                        const distToStart = Math.sqrt(Math.pow(i - startCoords.r, 2) + Math.pow(j - startCoords.c, 2));
                        const isWall = (r, c) => (r < 0 || r >= mazeRows || c < 0 || c >= mazeCols || mazeLayout[r][c] === 1);
                        const wallUp = isWall(i - 1, j);
                        const wallDown = isWall(i + 1, j);
                        const wallLeft = isWall(i, j - 1);
                        const wallRight = isWall(i, j + 1);
                        const wallCount = (wallUp ? 1:0) + (wallDown ? 1:0) + (wallLeft ? 1:0) + (wallRight ? 1:0);

                       if ((wallCount === 3 || (wallCount === 2 && !(wallUp && wallDown) && !(wallLeft && wallRight))) && distToStart > 1.5 && cell !== 'L' && cell !== 'T') {
                            const lightX = x + (Math.random() - 0.5) * cellSize * 0.2;
                            const lightZ = z + (Math.random() - 0.5) * cellSize * 0.2;
                            createStreetLight(lightX, 0, lightZ);
                        }
                    }

                     switch (cell) {
                        case 'S': startPos.set(x, playerHeight, z); break;
                        case 'L': createLandmark(x, z, landmarkCounter++); break;
                        case 'J': createWall(x, 0.75, z, cellSize, 1.5, cellSize, 0xff8c00); break;
                        case 'C': createWall(x, 2.25, z, cellSize, 1.5, cellSize, 0x708090); break;
                        case 'T':
                            const dist = Math.sqrt(Math.pow(i - startCoords.r, 2) + Math.pow(j - startCoords.c, 2));
                            if (dist > minDistFromStart) {
                                createTurret(x, z);
                            }
                            break;
                    }
                }
            }
            
            if (landmarks.length > 0) {
                const lastLandmark = landmarks[landmarks.length - 1];
                createHeartBalloon(lastLandmark.position.x, lastLandmark.position.y, lastLandmark.position.z);
            }

            camera.position.copy(startPos);
            camera.quaternion.set(0, 0, 0, 1);
            euler.set(0, Math.PI, 0, 'YXZ');
            camera.quaternion.setFromEuler(euler);
            scene.userData.mazeLayout = mazeLayout;
            scene.userData.mazeRows = mazeRows;
            scene.userData.mazeCols = mazeCols;
            scene.userData.cellSize = cellSize;
            nextLandmarkIndex = 0;
            landmarkCounterElement.style.display = 'block';
            updateLandmarkCounter();
            
            minimapUsesLeft = 8;
            mapUsesCounterElement.style.display = 'block';
            updateMapUsesCounter();
        }
        
        function setupStage10_Timed0() { const layout = [['S', 0, 1, 0, 0], [1, 0, 1, 0, 1], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 'E']]; setupTimedMazeLevel(layout); }
        function setupStage11_Timed1() { const layout = [['S', 0, 0, 0, 1, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 1, 'J', 1, 0], [0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 0, 1, 1, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 'E']]; setupTimedMazeLevel(layout); }
        function setupStage12_Timed2() { const layout = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 'S', 0, 1, 0, 0, 'J', 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 'C', 0, 1], [1, 1, 1, 0, 1, 1, 'C', 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1], [1, 'J', 0, 0, 0, 0, 0, 1, 0, 0, 0, 'J', 1], [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 0, 'C', 0, 0, 0, 0, 0, 0, 0, 'E', 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],]; setupTimedMazeLevel(layout); }
        function setupStage13_Timed3() { const layout = [['S', 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 'J', 0], [1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 1, 'C', 1, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 'J', 1, 1, 0, 1, 1, 1, 1, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0], [0, 'C', 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 'J', 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 'C', 0, 0, 0, 0, 0, 0, 0, 'E'],]; setupTimedMazeLevel(layout); }
        function setupStage14_Chase1() { const layout = [[1, 1, 1, 1, 1, 1, 1], [1, 'S', 0, 1, 0, 'N', 1], [1, 0, 0, 0, 0, 0, 1], [1, 'N', 1, 0, 1, 0, 1], [1, 1, 1, 1, 1, 1, 1]]; setupChaseMazeLevel(layout, 2); }
        function setupStage15_Chase2() { const layout = [[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 'S', 0, 0, 1, 'J', 1, 'N', 1], [1, 1, 0, 1, 1, 0, 1, 0, 1], [1, 0, 0, 'N', 0, 0, 'C', 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1], [1, 'N', 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]; setupChaseMazeLevel(layout, 3); }
        function setupStage16_Chase3() { const layout = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 'S', 0, 0, 0, 'J', 0, 1, 'N', 1], [1, 1, 1, 0, 1, 1, 0, 1, 0, 1], [1, 'N', 0, 0, 0, 1, 'C', 0, 0, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 'N', 0, 0, 'N', 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]; setupChaseMazeLevel(layout, 4); }
        function setupStage17_Landmark1() { const layout = [[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 'S', 0, 0, 1, 'C', 0, 'L', 1], [1, 1, 1, 0, 1, 0, 1, 1, 1], [1, 0, 'J', 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1], [1, 1, 'L', 1, 1, 'J', 1, 0, 1], [1, 'C', 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]; setupLandmarkMazeLevel(layout); }
        function setupStage18_Landmark2() { const layout = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 'S', 0, 0, 0, 1, 'L', 0, 'J', 0, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [1, 0, 0, 'C', 0, 0, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 'L', 1], [1, 'L', 1, 0, 1, 1, 0, 0, 'C', 0, 1], [1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1], [1, 0, 'J', 0, 1, 0, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]; setupLandmarkMazeLevel(layout); }
        function setupStage19_Landmark3() { const layout = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 'S', 0, 1, 0, 0, 0, 1, 'J', 0, 0, 'L', 1], [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1], [1, 0, 0, 'L', 0, 1, 'C', 0, 0, 1, 0, 0, 1], [1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 'L', 1, 1, 1, 1, 0, 1], [1, 0, 1, 'J', 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 'L', 1], [1, 0, 0, 0, 'C', 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]; setupLandmarkMazeLevel(layout); }
        function setupStage17_Landmark1_2() { const layout = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],[1, 'S', 0, 0, 0, 1, 0, 0, 'L', 1],[1, 1, 1, 0, 1, 1, 0, 1, 0, 1],[1, 0, 0, 0, 1, 0, 0, 1, 0, 1],[1, 0, 1, 1, 1, 0, 1, 1, 0, 1],[1, 0, 1, 0, 0, 0, 1, 0, 0, 1],[1, 'L', 1, 0, 1, 0, 1, 0, 1, 1],[1, 0, 0, 0, 1, 0, 0, 0, 0, 1],[1, 0, 1, 'L', 1, 1, 1, 1, 0, 1],[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]; setupLandmarkMazeLevel(layout); }
        function setupStage18_Landmark2_2() { const layout = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],[1, 'S', 0, 0, 0, 1, 0, 0, 0, 'L', 1],[1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1],[1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1],[1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1],[1, 'L', 0, 0, 1, 'L', 1, 0, 0, 0, 1],[1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1],[1, 0, 0, 0, 0, 0, 0, 0, 1, 'L', 1],[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]; setupLandmarkMazeLevel(layout); }
        function setupStage19_Landmark3_2() { const layout = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],[1, 'S', 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],[1, 1, 1, 0, 1, 1, 1, 0, 1, 'L', 1, 0, 1],[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1],[1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 'L', 1],[1, 0, 1, 'L', 1, 0, 0, 0, 0, 0, 1, 0, 1],[1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],[1, 1, 1, 1, 1, 'L', 1, 0, 1, 1, 1, 0, 1],[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],[1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 'L', 1],[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]; setupLandmarkMazeLevel(layout); }
        
        function setupStage22_TurretMaze1() { const layout = [[1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,1,'T',0,0,0,1],[1,1,1,0,1,0,1,1,0,1],[1,0,0,0,0,0,1,0,'L',1],[1,0,1,'T',1,1,1,0,1,1],[1,0,0,1,0,0,0,0,0,1],[1,1,0,1,'T',1,0,1,'T',1],[1,0,0,0,0,0,0,0,0,1],[1,'L',0,0,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1]]; setupLandmarkMazeLevel(layout); }
        function setupStage23_TurretMaze2() { const layout = [[1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,1,0,0,'T',0,0,1],[1,1,1,0,1,'T',1,1,1,0,1],[1,'L',0,0,0,0,0,0,0,'L',1],[1,1,1,1,0,1,1,1,1,1,1],[1,'T',0,0,0,'T',0,0,0,'T',1],[1,1,1,1,1,1,0,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,'L',1],[1,'T',0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1]]; setupLandmarkMazeLevel(layout); }
        function setupStage24_TurretMaze3() { const layout = [[1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,0,1,'T',0,0,0,1,0,1],[1,1,'T',1,0,1,0,1,1,0,1,0,1],[1,0,0,0,0,1,0,0,'L',0,1,'T',1],[1,0,1,1,1,1,1,0,1,0,1,0,1],[1,0,'L',0,0,0,1,0,'T',0,0,0,1],[1,1,1,1,1,0,1,1,1,1,1,0,1],[1,'T',0,0,0,0,0,0,'L',0,0,0,1],[1,0,1,1,1,1,1,0,1,1,'T',1,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,'L',0,'T',1,0,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,'T',0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1]]; setupLandmarkMazeLevel(layout); }
        function setupStage25_TurretMaze4() { const layout = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,0,1,0,0,1,0,0,1,0,'T',0,1],[1,1,1,0,1,0,1,1,'T',0,1,0,1,0,1],[1,0,0,0,1,0,'L',0,1,0,1,0,0,0,1],[1,0,1,1,1,1,1,0,1,0,1,1,1,0,1],[1,0,'T',0,0,0,0,0,1,0,0,0,1,0,1],[1,1,1,1,0,1,1,1,1,1,0,1,1,'L',1],[1,'L',0,0,0,0,'T',0,0,0,0,0,0,0,1],[1,1,1,0,1,1,1,1,1,1,1,1,0,1,1],[1,'T',0,0,0,1,0,0,0,0,0,0,'T',0,1],[1,0,1,1,1,1,0,1,1,1,1,0,1,0,1],[1,0,'L',0,0,0,0,1,'T',0,0,0,1,0,1],[1,0,1,1,1,1,1,1,0,1,1,1,1,'L',1],[1,'T',0,0,0,0,0,0,0,0,'T',0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]; setupLandmarkMazeLevel(layout); }
        function setupStage26_TurretMaze5() { const layout = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,'S',0,'T',0,0,1,0,0,1,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,1,0,1,1,0,1],[1,0,'L',0,0,0,1,0,'T',0,0,0,0,'L',1],[1,1,1,1,1,0,1,1,1,0,0,0,0,0,1],[1,'T',0,0,0,0,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,1,1,1,1,0,1,1,1,1,1],[1,0,'L',0,0,0,1,0,'T',0,0,0,0,'T',1],[1,1,1,1,1,0,1,0,1,1,1,1,0,1,1],[1,'T',0,0,0,0,1,0,'L',0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,'T',0,0,0,0,0,0,0,1,0,0,0,1],[1,0,1,1,1,1,1,1,1,0,1,'T',1,'L',1],[1,0,'L',0,'T',0,0,0,0,0,1,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]; setupLandmarkMazeLevel(layout); }

        function setupStage_Final() {
            camera.position.set(0, playerHeight, 8);
            camera.lookAt(0, playerHeight, 0);
            euler.setFromQuaternion(camera.quaternion, 'YXZ');
            createFloor(30, 30);
            scene.background.set(0x141428);
            scene.fog = new THREE.Fog(0x141428, 20, 100);
            if (fireworksInterval) clearInterval(fireworksInterval);
            fireworksInterval = setInterval(() => {
                const x = (Math.random() - 0.5) * 40;
                const z = (Math.random() - 0.5) * 40 - 10;
                create3DFirework(new THREE.Vector3(x, 0, z));
            }, 1000);
            const totalStarsEarned = Object.values(levelStars).reduce((sum, stars) => sum + stars, 0);
            const maxStars = Object.keys(starTimeThresholds).length * 3;
            let rank, rankColor, encouragementMessage;
            if (totalStarsEarned >= maxStars * (2/3)) {
                rank = '认知大师<br><span class="podium-rank-en">Cognitive Master</span>';
                rankColor = '#ffd700';
                encouragementMessage = `太厉害了！您已精通所有认知挑战，展现了卓越的综合能力！<br><span class="en">Amazing! You've mastered all cognitive challenges, demonstrating outstanding comprehensive abilities!</span>`;
            } else if (totalStarsEarned >= maxStars * (1/3)) {
                rank = '认知专家<br><span class="podium-rank-en">Cognitive Expert</span>';
                rankColor = '#c0c0c0';
                encouragementMessage = `非常出色！您掌握了绝大部分认知技巧，获得了高级认证！<br><span class="en">Excellent work! You've mastered most cognitive skills and earned an advanced certification!</span>`;
            } else {
                rank = '认知学徒<br><span class="podium-rank-en">Cognitive Apprentice</span>';
                rankColor = '#cd7f32';
                encouragementMessage = `恭喜您完成了所有训练，获得了基础能力认证！每一步都是了不起的进步！<br><span class="en">Congratulations on completing all the training and receiving a basic certification! Every step is great progress!</span>`;
            }
            document.getElementById('results-title').textContent = '综合能力认证 / Cognitive Mastery';
            document.getElementById('player-final-title').innerHTML = `祝贺您, ${playerProfile.title}!<br><span style="font-size:16px; color: #ccc;">Congratulations, ${playerProfile.title}!</span>`;
            document.getElementById('encouragement-message').innerHTML = encouragementMessage;
            const podium1 = document.getElementById('podium-1');
            const podium2 = document.getElementById('podium-2');
            const podium3 = document.getElementById('podium-3');
            podium1.innerHTML = `<div class="podium-rank">1</div>`;
            podium2.innerHTML = `<div class="podium-rank">2</div>`;
            podium3.innerHTML = `<div class="podium-rank">3</div>`;
            const playerPodiumHTML = `<div class="podium-rank" style="color:${rankColor};">${rank}</div><div class="podium-stars">${totalStarsEarned} ★</div>`;
            if (rank.includes('Master')) {
                podium1.innerHTML = playerPodiumHTML;
            } else if (rank.includes('Expert')) {
                podium2.innerHTML = playerPodiumHTML;
            } else {
                podium3.innerHTML = playerPodiumHTML;
            }
            resultsOverlay.style.display = 'flex';
            blockerElement.style.display = 'none';
            if (document.pointerLockElement) document.exitPointerLock();
        }
        
        function createToyGun() {
            toyGun = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x4a90e2, roughness: 0.4, metalness: 0.1 });
            const bodyGeo = new THREE.BoxGeometry(0.25, 0.25, 0.6);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.set(0, -0.1, -0.25);
            toyGun.add(body);
            const handleGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.4, 16);
            const handle = new THREE.Mesh(handleGeo, bodyMat);
            handle.position.set(0, -0.4, -0.15);
            handle.rotation.x = -0.3;
            toyGun.add(handle);
            const barrelMat = new THREE.MeshStandardMaterial({ color: 0xf5a623, roughness: 0.2, metalness: 0.5 });
            const barrelGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 16);
            const barrel = new THREE.Mesh(barrelGeo, barrelMat);
            barrel.position.set(0, -0.05, -0.7);
            barrel.rotation.x = Math.PI / 2;
            toyGun.add(barrel);
            const sightMat = new THREE.MeshStandardMaterial({ color: 0x9b9b9b });
            const sightGeo = new THREE.BoxGeometry(0.05, 0.05, 0.15);
            const sight = new THREE.Mesh(sightGeo, sightMat);
            sight.position.set(0, 0.05, -0.4);
            toyGun.add(sight);
            toyGun.position.set(0.5, -0.5, -1.0);
            toyGun.rotation.y = -0.15;
        }

        function handleShooting() {
            shootCooldown = 0.2;
            const bulletGeo = new THREE.SphereGeometry(0.05, 16, 8);
            const bulletMat = new THREE.MeshStandardMaterial({ color: 0xffa500, emissive: 0xffa500, emissiveIntensity: 2 });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            const muzzlePosition = new THREE.Vector3();
            const muzzle = toyGun.children[2];
            muzzle.getWorldPosition(muzzlePosition);
            raycaster.setFromCamera(centerScreen, camera);
            
            const shootableObjects = [...collidables, ...turrets.map(t => t.children).flat()];
            const intersects = raycaster.intersectObjects(shootableObjects, true);

            let targetPosition;
            if (intersects.length > 0) {
                targetPosition = intersects[0].point;
            } else {
                targetPosition = new THREE.Vector3();
                camera.getWorldDirection(targetPosition);
                targetPosition.multiplyScalar(1000).add(camera.position);
            }
            const bulletVelocity = new THREE.Vector3().subVectors(targetPosition, muzzlePosition).normalize();
            bullet.position.copy(muzzlePosition);
            bullet.velocity = bulletVelocity.multiplyScalar(100);
            bullet.life = 5;
            bullet.userData.isPlayerBullet = true;
            bullets.push(bullet);
            scene.add(bullet);
        }

        function updateBullets(deltaTime) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.life -= deltaTime;
                const bulletMoveVector = bullet.velocity.clone().multiplyScalar(deltaTime);
                const bulletRaycaster = new THREE.Raycaster(bullet.position, bullet.velocity.clone().normalize());
                
                let collision = false;

                if (bullet.userData.isPlayerBullet) {
                    const shootableObjects = [...collidables, ...turrets.map(t => t.children).flat()];
                    const intersects = bulletRaycaster.intersectObjects(shootableObjects, true);
                    if (intersects.length > 0 && intersects[0].distance < bulletMoveVector.length()) {
                        const intersect = intersects[0];
                        bullet.position.copy(intersect.point);
                        
                        let hitObject = intersect.object;
                        while(hitObject.parent && !hitObject.userData.isTurret) {
                            hitObject = hitObject.parent;
                        }

                        if (hitObject.userData.isTurret) {
                            hitObject.userData.health--;
                            
                            if (!hitObject.userData.isHit) {
                                hitObject.userData.isHit = true;
                                hitObject.traverse(child => {
                                    if(child.isMesh) child.material.emissive.setHex(0xff0000);
                                });

                                setTimeout(() => {
                                    if (hitObject && hitObject.parent) {
                                        let i = 0;
                                        hitObject.traverse(child => {
                                            if(child.isMesh && i < hitObject.userData.originalEmissives.length) {
                                                if (child === hitObject.userData.originalEmissives[i].obj) {
                                                    child.material.emissive.setHex(hitObject.userData.originalEmissives[i].emissive);
                                                }
                                                i++;
                                            }
                                        });
                                        hitObject.userData.isHit = false;
                                    }
                                }, 500);
                            }

                             if (hitObject.userData.health <= 0) {
                                const turretIndex = turrets.indexOf(hitObject);
                                if (turretIndex > -1) turrets.splice(turretIndex, 1);
                                
                                const collidableIndex = collidables.indexOf(hitObject);
                                if (collidableIndex > -1) collidables.splice(collidableIndex, 1);

                                scene.remove(hitObject);
                                create3DFirework(hitObject.position);

                                if (playerHealth < maxPlayerHealth) {
                                    playerHealth++;
                                    updateHealthBar();
                                }
                                minimapUsesLeft++;
                                updateMapUsesCounter();
                            }
                        } else if (intersect.object.userData.isTargetRing) {
                            createBulletHole(intersect);
                        }
                        collision = true;
                    }
                } 
                else {
                    const playerBox = new THREE.Box3().setFromCenterAndSize(camera.position, new THREE.Vector3(playerRadius*2, playerHeight, playerRadius*2));
                    playerBox.min.y = camera.position.y - playerHeight;
                    playerBox.max.y = camera.position.y;
                    if (playerBox.containsPoint(bullet.position)) {
                        playerHealth--;
                        updateHealthBar();
                        if (playerHealth <= 0) {
                            handlePlayerDeath();
                        }
                        collision = true;
                    } else {
                        const intersects = bulletRaycaster.intersectObjects(collidables, true);
                        if (intersects.length > 0 && intersects[0].distance < bulletMoveVector.length()) {
                            collision = true;
                        }
                    }
                }

                if (collision || bullet.life <= 0) {
                    scene.remove(bullet);
                    bullet.geometry.dispose();
                    bullet.material.dispose();
                    bullets.splice(i, 1);
                    continue;
                }
                bullet.position.add(bulletMoveVector);
            }
        }
        
        function createBulletHole(intersect) {
            const heartShape = new THREE.Shape();
            const s = 0.05;
            heartShape.moveTo(0, -1.5 * s);
            heartShape.bezierCurveTo(-3 * s, 1.5 * s, -1 * s, 3 * s, 0, 2 * s);
            heartShape.bezierCurveTo(1 * s, 3 * s, 3 * s, 1.5 * s, 0, -1.5 * s);
            const holeGeo = new THREE.ShapeGeometry(heartShape);
            const holeMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 1, side: THREE.DoubleSide });
            const holeMesh = new THREE.Mesh(holeGeo, holeMat);
            let targetParent = intersect.object;
            while(targetParent.parent && targetParent.name !== 'warmup_target') targetParent = targetParent.parent;
            const hole = { mesh: holeMesh, life: 3.0 };
            if (targetParent && targetParent.name === 'warmup_target') {
                const localPoint = targetParent.worldToLocal(intersect.point.clone());
                holeMesh.position.copy(localPoint);
                holeMesh.position.addScaledVector(intersect.face.normal, 0.02); 
                holeMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), intersect.face.normal);
                holeMesh.rotation.z = Math.PI;
                targetParent.add(holeMesh);
            } else {
                holeMesh.position.copy(intersect.point);
                holeMesh.lookAt(intersect.point.clone().add(intersect.face.normal));
                holeMesh.position.addScaledVector(intersect.face.normal, 0.01);
                scene.add(holeMesh);
            }
            bulletHoles.push(hole);
        }

        function updateBulletHoles(deltaTime) {
            for (let i = bulletHoles.length - 1; i >= 0; i--) {
                const hole = bulletHoles[i];
                hole.life -= deltaTime;
                if (hole.life <= 0) {
                    hole.mesh.parent.remove(hole.mesh);
                    hole.mesh.geometry.dispose();
                    hole.mesh.material.dispose();
                    bulletHoles.splice(i, 1);
                } else if (hole.life <= 1.0) {
                    hole.mesh.material.opacity = hole.life;
                }
            }
        }


        function handleWarmupAiming() { raycaster.setFromCamera(centerScreen, camera); const intersects = raycaster.intersectObjects(stageObjects, true); let currentHit = null; for (const intersect of intersects) { if (intersect.object.userData.isTargetRing) { currentHit = intersect.object; break; } } if (highlightedRing && highlightedRing !== currentHit) { highlightedRing.material.emissive.setHex(0x000000); highlightedRing = null; } if (currentHit && currentHit !== highlightedRing) { highlightedRing = currentHit; highlightedRing.material.emissive.setHex(0x666666); } }
        function handleAiming() { raycaster.setFromCamera(centerScreen, camera); const intersects = raycaster.intersectObjects(stage1Targets); if (intersects.length > 0) { const aimedObject = intersects[0].object; if (aimedObject.userData.isTarget && !aimedTargets.has(aimedObject)) { aimedObject.material.emissive.setHex(0x00ff00); aimedTargets.add(aimedObject); updateInstructions(); } } }
        function updatePlayer(deltaTime) { 
            const moveDirection = new THREE.Vector3(); 
            if (currentStage === 5) {
                if (keys['KeyA']) moveDirection.x = -1; 
                if (keys['KeyD']) moveDirection.x = 1;
            } else {
                if (keys['KeyW']) moveDirection.z = -1; 
                if (keys['KeyS']) moveDirection.z = 1; 
                if (keys['KeyA']) moveDirection.x = -1; 
                if (keys['KeyD']) moveDirection.x = 1;
            }

            if (!hasPlayerMoved && moveDirection.lengthSq() > 0) { hasPlayerMoved = true; if (currentStage >= 16 && currentStage <= 26) { minimapContainer.style.display = 'none'; } } if (!canPlayerMove) return; const wantsToCrouch = (keys['ShiftLeft'] || keys['ShiftRight']); if (wantsToCrouch) { if (!isCrouching && playerOnFloor) { camera.position.y -= (playerHeight - playerCrouchHeight); } isCrouching = true; } else { if (isCrouching) { const upRaycaster = new THREE.Raycaster(camera.position, new THREE.Vector3(0, 1, 0), 0, playerHeight - playerCrouchHeight + 0.1); const ceilingIntersections = upRaycaster.intersectObjects(collidables); if (ceilingIntersections.length === 0) { camera.position.y += (playerHeight - playerCrouchHeight); isCrouching = false; } } } const speed = (isCrouching ? crouchSpeed : moveSpeed); if (moveDirection.lengthSq() > 0) { moveDirection.normalize(); const worldMoveDirection = moveDirection.clone().applyQuaternion(camera.quaternion); camera.position.x += worldMoveDirection.x * speed * deltaTime; camera.position.z += worldMoveDirection.z * speed * deltaTime; } const currentHeight = isCrouching ? playerCrouchHeight : playerHeight; const downRaycaster = new THREE.Raycaster(camera.position, new THREE.Vector3(0, -1, 0), 0, currentHeight + 0.2); const groundIntersections = downRaycaster.intersectObjects([...collidables, ...stageObjects.filter(o => o.geometry && o.geometry.type === 'PlaneGeometry')]); playerOnFloor = groundIntersections.length > 0; if (playerOnFloor) { const groundY = groundIntersections[0].point.y; if (playerVelocity.y <= 0) { playerVelocity.y = 0; camera.position.y = groundY + currentHeight; } } else { playerVelocity.y -= gravity * deltaTime; } if (keys['Space'] && playerOnFloor) { playerVelocity.y = jumpForce; playerOnFloor = false; } camera.position.y += playerVelocity.y * deltaTime; const playerBox = new THREE.Box3().setFromCenterAndSize(camera.position, new THREE.Vector3(playerRadius*2, currentHeight, playerRadius*2)); playerBox.min.y = camera.position.y - currentHeight; playerBox.max.y = camera.position.y; collidables.forEach(collidable => { const collidableBox = new THREE.Box3().setFromObject(collidable); if (playerBox.intersectsBox(collidableBox)) { const center = new THREE.Vector3(); playerBox.getCenter(center); const collidableCenter = new THREE.Vector3(); collidableBox.getCenter(collidableCenter); const overlap = new THREE.Vector3().subVectors(center, collidableCenter); const halfSizePlayer = new THREE.Vector3(); playerBox.getSize(halfSizePlayer).multiplyScalar(0.5); const halfSizeCollidable = new THREE.Vector3(); collidableBox.getSize(halfSizeCollidable).multiplyScalar(0.5); const penetration = new THREE.Vector3((halfSizePlayer.x + halfSizeCollidable.x) - Math.abs(overlap.x), (halfSizePlayer.y + halfSizeCollidable.y) - Math.abs(overlap.y), (halfSizePlayer.z + halfSizeCollidable.z) - Math.abs(overlap.z)); if (penetration.x < penetration.z && penetration.x < penetration.y) { camera.position.x += penetration.x * Math.sign(overlap.x); } else if (penetration.z < penetration.y) { camera.position.z += penetration.z * Math.sign(overlap.z); } else { if (playerVelocity.y > 0 && overlap.y < 0) { playerVelocity.y = 0; } camera.position.y += penetration.y * Math.sign(overlap.y); } } }); }
        function updateNPC(npc, deltaTime) { const fleeVector = new THREE.Vector3().subVectors(npc.position, camera.position); fleeVector.y = 0; fleeVector.normalize(); const avoidanceVector = new THREE.Vector3(); const feelerLength = 2.0; let npcDirection = npc.velocity.clone().normalize(); if(npcDirection.lengthSq() === 0) { npc.getWorldDirection(npcDirection); npcDirection.y = 0; npcDirection.normalize(); } const wallRaycaster = new THREE.Raycaster(npc.position, npcDirection); const intersections = wallRaycaster.intersectObjects(collidables); if (intersections.length > 0 && intersections[0].distance < feelerLength) { const wallNormal = intersections[0].face.normal.clone(); avoidanceVector.copy(npcDirection).reflect(wallNormal).multiplyScalar(1.5); } let steeringDirection = fleeVector.add(avoidanceVector); if (steeringDirection.lengthSq() === 0) { steeringDirection.set(Math.random() - 0.5, 0, Math.random() - 0.5); } steeringDirection.normalize(); if (Math.random() > 0.98) { const randomAngle = (Math.random() - 0.5) * Math.PI; steeringDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle); } npc.velocity.lerp(steeringDirection, 0.05); const moveStep = npc.velocity.clone().normalize().multiplyScalar(moveSpeed * 0.8 * deltaTime); const nextPos = npc.position.clone().add(moveStep); const moveDistance = moveStep.length(); const collisionRaycaster = new THREE.Raycaster(npc.position, moveStep.clone().normalize()); const collisionIntersections = collisionRaycaster.intersectObjects(collidables); if (collisionIntersections.length === 0 || collisionIntersections[0].distance > moveDistance + 1.5) { npc.position.copy(nextPos); } else { const wallNormal = collisionIntersections[0].face.normal.clone(); npc.velocity.reflect(wallNormal); } npc.position.y = 0.9; }
        
        function updateKeyDisplay() {
            if (keyW) keyW.classList.toggle('key-active', !!keys['KeyW']);
            if (keyA) keyA.classList.toggle('key-active', !!keys['KeyA']);
            if (keyS) keyS.classList.toggle('key-active', !!keys['KeyS']);
            if (keyD) keyD.classList.toggle('key-active', !!keys['KeyD']);
            if (keySpace) keySpace.classList.toggle('key-active', !!keys['Space']);
            if (keyShift) keyShift.classList.toggle('key-active', !!(keys['ShiftLeft'] || keys['ShiftRight']));
        }

        function updateNpcCounter() { const total = scene.userData.totalNpcs || 0; const remaining = npcs.length; npcCounterElement.innerHTML = `已捕捉 / Caught: ${total - remaining} / ${total}`; }
        function updateLandmarkCounter() { landmarkCounterElement.innerHTML = `已找到 / Found: ${nextLandmarkIndex} / ${landmarks.length}`; }
        function updateGenericCounter(text) { genericCounterElement.innerHTML = text; }
        
        function updateMapUsesCounter() {
            mapUsesCounterElement.innerHTML = `地图剩余次数: ${minimapUsesLeft}<br><span style="font-size:14px; color: #ccc;">Map Uses Left: ${minimapUsesLeft}</span>`;
        }

        function showNarration(text) {
            narrationBox.innerHTML = text;
            narrationBox.style.display = 'block';
            if (!text.toLowerCase().includes('cancel')) {
                setTimeout(() => {
                    if (narrationBox.innerHTML === text) { 
                        narrationBox.style.display = 'none';
                    }
                }, 4000);
            }
        }

        function create3DFirework(position) {
            const particleCount = 50;
            const colors = [0xffa500, 0xff4500, 0xffff00, 0x00ff00, 0x00ffff];
            for (let i = 0; i < particleCount; i++) {
                const particleMat = new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)], transparent: true });
                const particleGeo = new THREE.SphereGeometry(0.1, 8, 8);
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.copy(position);
                const velocity = new THREE.Vector3((Math.random() - 0.5) * 10, Math.random() * 10 + 5, (Math.random() - 0.5) * 10);
                firework3DParticles.push({ mesh: particle, velocity: velocity, life: 1.5, initialLife: 1.5 });
                scene.add(particle);
            }
        }

        function update3DFireworks(deltaTime) {
            for (let i = firework3DParticles.length - 1; i >= 0; i--) {
                const p = firework3DParticles[i];
                p.life -= deltaTime;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                    firework3DParticles.splice(i, 1);
                } else {
                    p.velocity.y -= 9.8 * deltaTime;
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(deltaTime));
                    p.mesh.material.opacity = p.life / p.initialLife;
                }
            }
        }

        function createTrailParticle(position) {
            const trailGeo = new THREE.CircleGeometry(0.8, 16);
            const trailMat = new THREE.MeshBasicMaterial({ 
                color: 0xffff00, 
                transparent: true, 
                opacity: 0.6 
            });
            const particle = new THREE.Mesh(trailGeo, trailMat);
            particle.position.copy(position);
            particle.position.y = 0.01; 
            particle.rotation.x = -Math.PI / 2;
            scene.add(particle);
            trailParticles.push({ mesh: particle, life: 3.0, initialLife: 3.0 });
        }

        function updateTrailParticles(deltaTime) {
            for (let i = trailParticles.length - 1; i >= 0; i--) {
                const p = trailParticles[i];
                p.life -= deltaTime;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                    trailParticles.splice(i, 1);
                } else {
                    p.mesh.material.opacity = (p.life / p.initialLife) * 0.6;
                }
            }
        }

        function drawMinimap() {
            if (!minimapCtx || !scene.userData.mazeCols) return;
            const rows = scene.userData.mazeRows;
            const cols = scene.userData.mazeCols;
            const cellSize = scene.userData.cellSize;
            const canvasWidth = minimap.width;
            const canvasHeight = minimap.height;
            const scale = Math.min(canvasWidth / (cols * cellSize), canvasHeight / (rows * cellSize));
            const mapWidth = cols * cellSize * scale;
            const mapHeight = rows * cellSize * scale;
            const mapOffsetX = (canvasWidth - mapWidth) / 2;
            const mapOffsetY = (canvasHeight - mapHeight) / 2;
            const worldOffsetX = -(cols * cellSize) / 2;
            const worldOffsetZ = -(rows * cellSize) / 2;
            minimapCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            minimapCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            const worldToMap = (worldPos) => ({ x: mapOffsetX + ((worldPos.x - worldOffsetX) * scale), y: mapOffsetY + ((worldPos.z - worldOffsetZ) * scale) });
            if (scene.userData.mazeLayout) {
                const layout = scene.userData.mazeLayout;
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const cell = layout[i][j];
                        const x = mapOffsetX + j * cellSize * scale;
                        const y = mapOffsetY + i * cellSize * scale;
                        const w = cellSize * scale;
                        const h = cellSize * scale;
                        if (cell === 1) minimapCtx.fillStyle = '#666';
                        else if (cell === 'J') minimapCtx.fillStyle = '#ff8c00';
                        else if (cell === 'C') minimapCtx.fillStyle = '#708090';
                        else if (cell === 'T') minimapCtx.fillStyle = '#ff4500';
                        else minimapCtx.fillStyle = '#333';
                        minimapCtx.fillRect(x, y, w, h);
                    }
                }
            } else if (currentStage === 6 && scene.userData.walls) {
                 minimapCtx.fillStyle = '#666';
                 scene.userData.walls.forEach(wall => {
                    const wallCenterMap = worldToMap(new THREE.Vector3(wall.x, 0, wall.z));
                    const w = wall.w * scale;
                    const h = wall.d * scale;
                    minimapCtx.fillRect(wallCenterMap.x - w/2, wallCenterMap.y - h/2, (w < 2 && w > 0) ? 2.5 : w, (h < 2 && h > 0) ? 2.5 : h);
                 });
            }
            if (currentStage === 6) {
                const route = scene.userData.routePath;
                if(route && route.length > 0) {
                    minimapCtx.strokeStyle = '#ffdd57';
                    minimapCtx.lineWidth = 2;
                    minimapCtx.setLineDash([4, 4]);
                    const startPoint = worldToMap(route[0]);
                    minimapCtx.beginPath();
                    minimapCtx.moveTo(startPoint.x, startPoint.y);
                    for(let i = 1; i < route.length; i++) {
                        const point = worldToMap(route[i]);
                        minimapCtx.lineTo(point.x, point.y);
                    }
                    minimapCtx.stroke();
                    minimapCtx.setLineDash([]);
                }
                if (scene.userData.startPos) {
                    const startMapPos = worldToMap(scene.userData.startPos);
                    minimapCtx.fillStyle = '#00ff00';
                    minimapCtx.beginPath();
                    minimapCtx.arc(startMapPos.x, startMapPos.y, 5, 0, 2 * Math.PI);
                    minimapCtx.fill();
                }
                if (scene.userData.endPos) {
                    const endMapPos = worldToMap(scene.userData.endPos);
                    minimapCtx.fillStyle = '#ff0000';
                    minimapCtx.beginPath();
                    minimapCtx.arc(endMapPos.x, endMapPos.y, 5, 0, 2 * Math.PI);
                    minimapCtx.fill();
                }
            } else if (currentStage >= 9 && currentStage <= 12) {
                const endMapPos = worldToMap(scene.userData.endPos); 
                minimapCtx.fillStyle = '#ff0000'; 
                minimapCtx.beginPath(); 
                minimapCtx.moveTo(endMapPos.x, endMapPos.y - 5); 
                for (let i = 0; i < 5; i++) { 
                    minimapCtx.lineTo(endMapPos.x + Math.cos((18 + i * 72) * Math.PI / 180) * 5, endMapPos.y - Math.sin((18 + i * 72) * Math.PI / 180) * 5); 
                    minimapCtx.lineTo(endMapPos.x + Math.cos((54 + i * 72) * Math.PI / 180) * 2, endMapPos.y - Math.sin((54 + i * 72) * Math.PI / 180) * 2); 
                } 
                minimapCtx.closePath(); 
                minimapCtx.fill(); 
            } else if (currentStage >= 13 && currentStage <= 15) {
                minimapCtx.fillStyle = '#0099ff'; 
                npcs.forEach(npc => { 
                    const npcMapPos = worldToMap(npc.position); 
                    minimapCtx.beginPath(); 
                    minimapCtx.arc(npcMapPos.x, npcMapPos.y, 2.5, 0, 2 * Math.PI); 
                    minimapCtx.fill(); 
                }); 
            } else if (currentStage >= 16 && currentStage <= 26) {
                landmarks.forEach((landmark) => {
                    const landmarkMapPos = worldToMap(landmark.position);
                    minimapCtx.fillStyle = landmark.userData.isFound ? '#00ff00' : '#ffff00';
                    minimapCtx.beginPath();
                    minimapCtx.arc(landmarkMapPos.x, landmarkMapPos.y, 4, 0, 2 * Math.PI);
                    minimapCtx.fill();
                    minimapCtx.fillStyle = '#000';
                    minimapCtx.font = 'bold 10px sans-serif';
                    minimapCtx.textAlign = 'center';
                    minimapCtx.textBaseline = 'middle';
                    minimapCtx.fillText(landmark.userData.number, landmarkMapPos.x, landmarkMapPos.y);
                });
            }
            const playerMapPos = worldToMap(camera.position);
            const angle = -euler.y;
            minimapCtx.save();
            minimapCtx.translate(playerMapPos.x, playerMapPos.y);
            minimapCtx.rotate(angle);
            minimapCtx.fillStyle = '#00ddff';
            minimapCtx.beginPath();
            minimapCtx.moveTo(0, -6);
            minimapCtx.lineTo(5, 4);
            minimapCtx.lineTo(0, 2);
            minimapCtx.lineTo(-5, 4);
            minimapCtx.closePath();
            minimapCtx.fill();
            minimapCtx.restore();
        }

        function createTurret(x, z) {
            const turretGroup = new THREE.Group();
            
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x6c757d, roughness: 0.7, metalness: 0.2 });
            const baseGeo = new THREE.CylinderGeometry(1.2, 1.5, 0.5, 8);
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.castShadow = true;
            turretGroup.add(base);

            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x495057, roughness: 0.6, metalness: 0.3 });
            const bodyGeo = new THREE.CylinderGeometry(0.8, 1, 1.5, 8);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1;
            body.castShadow = true;
            turretGroup.add(body);

            const headGroup = new THREE.Group();
            const headMat = new THREE.MeshStandardMaterial({ color: 0x343a40, roughness: 0.5, metalness: 0.5 });
            const headGeo = new THREE.SphereGeometry(0.7, 16, 8);
            const head = new THREE.Mesh(headGeo, headMat);
            head.castShadow = true;
            headGroup.add(head);

            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xdd0000, emissiveIntensity: 1 });
            const eyeGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 16);
            const eye = new THREE.Mesh(eyeGeo, eyeMat);
            eye.rotation.z = Math.PI / 2;
            eye.position.x = 0.6;
            headGroup.add(eye);
            
            headGroup.position.y = 1.8;
            turretGroup.add(headGroup);

            turretGroup.position.set(x, 0.25, z);
            
            const originalEmissives = [];
            turretGroup.traverse(child => {
                if (child.isMesh) {
                    originalEmissives.push({obj: child, emissive: child.material.emissive.getHex()});
                }
            });

            turretGroup.userData = {
                isTurret: true,
                health: 5,
                shootCooldown: 0,
                head: headGroup,
                eye: eye,
                isHit: false,
                originalEmissives: originalEmissives
            };

            turretGroup.castShadow = true;
            scene.add(turretGroup);
            stageObjects.push(turretGroup);
            turrets.push(turretGroup);
            collidables.push(turretGroup);
        }

        function updateTurrets(deltaTime) {
            turrets.forEach(turret => {
                const head = turret.userData.head;
                const distanceToPlayer = turret.position.distanceTo(camera.position);

                if (distanceToPlayer < 30) {
                    const turretDirection = new THREE.Vector3();
                    head.getWorldDirection(turretDirection);
                    const playerDirection = new THREE.Vector3().subVectors(camera.position, head.getWorldPosition(new THREE.Vector3()));
                    playerDirection.y -= 0.2;
                    playerDirection.normalize();

                    const angle = turretDirection.angleTo(playerDirection);
                    if(angle > 0.05) {
                        const cross = new THREE.Vector3().crossVectors(turretDirection, playerDirection);
                        head.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(cross.normalize(), Math.min(angle, deltaTime * 2)));
                    }
                    
                    const ray = new THREE.Raycaster(head.getWorldPosition(new THREE.Vector3()), playerDirection);
                    const intersects = ray.intersectObjects(collidables, true);
                    
                    let playerVisible = true;
                    if (intersects.length > 0 && intersects[0].distance < distanceToPlayer - 1) {
                        let hitObject = intersects[0].object;
                        let isSelfHit = false;
                        while(hitObject.parent) {
                            if (hitObject === turret) {
                                isSelfHit = true;
                                break;
                            }
                            hitObject = hitObject.parent;
                        }
                        if (!isSelfHit) {
                            playerVisible = false;
                        }
                    }

                    if (playerVisible && !turret.userData.isHit) {
                        turret.userData.eye.material.emissive.setHex(0xff0000);
                        if (turret.userData.shootCooldown <= 0) {
                            turret.userData.shootCooldown = 0.6;
                            fireTurretBullet(turret);
                        }
                    } else if (!playerVisible && !turret.userData.isHit) {
                         turret.userData.eye.material.emissive.setHex(0x550000);
                    }
                }
                if (turret.userData.shootCooldown > 0) {
                    turret.userData.shootCooldown -= deltaTime;
                }
            });
        }
        
        function fireTurretBullet(turret) {
            const bulletGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMat = new THREE.MeshStandardMaterial({ color: 0xff4500, emissive: 0xff4500, emissiveIntensity: 2 });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);

            const muzzlePosition = new THREE.Vector3();
            turret.userData.eye.getWorldPosition(muzzlePosition);
            
            const bulletVelocity = new THREE.Vector3().subVectors(camera.position, muzzlePosition).normalize();
            
            bullet.position.copy(muzzlePosition);
            bullet.velocity = bulletVelocity.multiplyScalar(30);
            bullet.life = 5;
            bullet.userData.isPlayerBullet = false;
            bullets.push(bullet);
            scene.add(bullet);
        }

        function updateHealthBar() {
            const percentage = (playerHealth / maxPlayerHealth) * 100;
            healthBar.style.width = `${percentage}%`;
            healthText.textContent = `HP: ${playerHealth} / ${maxPlayerHealth}`;
        }
        
        function handlePlayerDeath() {
            if (isPlayerDead) return;
            isPlayerDead = true;
            canPlayerMove = false;
            stopTimer();
            if (document.pointerLockElement) document.exitPointerLock();
            
            updateInstructions();
            blockerElement.addEventListener('click', () => loadStage(currentStage), { once: true });
            blockerElement.style.display = 'flex';
        }

    </script>
</body>
</html>
